<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LVtoExcel</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:18px;color:#111}
    h1{font-size:18px;margin:0 0 10px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .card{border:1px solid #ddd;border-radius:10px;padding:12px;margin-top:12px}
    button{padding:8px 12px;border-radius:8px;border:1px solid #bbb;background:#f7f7f7;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    input[type=file]{border:1px solid #bbb;padding:8px;border-radius:8px;background:#fff}
    #log{width:100%;height:140px;white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px}
    table{border-collapse:collapse;width:100%;font-size:12px}
    th,td{border:1px solid #ddd;padding:6px;vertical-align:top}
    th{background:#fafafa;position:sticky;top:0}
    .muted{color:#666;font-size:12px}
  </style>
</head>
<body>
  <h1>LVtoExcel (browser-only)</h1>
  <div class="muted">Loads local <code>pdf.min.js</code>, <code>pdf.worker.min.js</code>, <code>xlsx.full.min.js</code> from the same folder.</div>

  <div class="card">
    <div class="row">
      <input id="file" type="file" accept="application/pdf" />
      <button id="btnLoad">Load PDF</button>
      <button id="btnExtract" disabled>Extract</button>
      <button id="btnExport" disabled>Export XLSX</button>
    </div>
    <div style="margin-top:10px" class="muted">
      Output columns: Seite | Pos | Menge | Menge Einheit | EP | GP | Beschreibung
    </div>
  </div>

  <div class="card">
    <div style="font-weight:600;margin-bottom:6px">Log</div>
    <textarea id="log" readonly></textarea>
  </div>

  <div class="card" style="max-height:420px;overflow:auto">
    <div style="font-weight:600;margin-bottom:6px">Preview (first 50 rows)</div>
    <table id="tbl"></table>
  </div>

  <!-- Local libraries (no CDN) -->
  <script src="./pdf.min.js"></script>
  <script src="./xlsx.full.min.js"></script>

  <script>
  "use strict";

  // Manual version tag (YYYYMMDD_HHMM)
  const VERSION_TAG = "20251218_1200";

  // pdf.js worker must be enabled
  if (window.pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
    pdfjsLib.GlobalWorkerOptions.workerSrc = "./pdf.worker.min.js";
  }

  const elFile = document.getElementById("file");
  const elLoad = document.getElementById("btnLoad");
  const elExtract = document.getElementById("btnExtract");
  const elExport = document.getElementById("btnExport");
  const elLog = document.getElementById("log");
  const elTbl = document.getElementById("tbl");

  let pdfDoc = null;
  let extractedRows = [];

  function log(msg){
    elLog.value += msg + "\n";
    elLog.scrollTop = elLog.scrollHeight;
  }

  function normText(s){
    if (s == null) return "";
    return String(s)
      .replace(/\u00a0/g, " ")
      .replace(/\s+/g, " ")
      .trim();
  }

  function parseNumberDE(s){
    s = normText(s);
    if(!s) return null;
    s = s.replace(/[^0-9,.\-]/g, "");
    if(!s) return null;

    // If comma is present, treat it as decimal separator and dots as thousands
    if (s.indexOf(",") >= 0) s = s.replace(/\./g, "").replace(",", ".");
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  }

  // Turn pdf.js text items into lines by grouping close y coordinates.
  function itemsToLines(items){
    const pts = items
      .map(it => ({
        x: it.transform[4],
        y: it.transform[5],
        s: normText(it.str),
        w: (typeof it.width === "number" ? it.width : 0),
      }))
      .filter(p => p.s);

    // Group by y with tolerance
    pts.sort((a,b) => b.y - a.y);

    const lines = [];
    const yTol = 2.2;

    for(const p of pts){
      let line = null;
      for(const l of lines){
        if (Math.abs(l.y - p.y) <= yTol) { line = l; break; }
      }
      if(!line){
        line = { y: p.y, parts: [] };
        lines.push(line);
      }
      line.parts.push({ x: p.x, s: p.s, w: p.w });
    }

    for(const l of lines){
      l.parts.sort((a,b)=>a.x-b.x);
      l.text = l.parts.map(pp=>pp.s).join(" ").trim();
    }

    return lines;
  }

  // Identify dotted numeric codes
  function isDottedNumeric(s){
    s = normText(s);
    if(!s) return false;
    return /^\d[\d\.]*\d$/.test(s) && s.indexOf(".") !== -1;
  }

  // "pos": dotted numeric code ending with 4 digits (hard rule)
  // "title": dotted numeric code NOT ending with 4 digits
  function classifyNrStrict(s){
    s = normText(s);
    if(!isDottedNumeric(s)) return null;
    const parts = s.split(".");
    const last = parts[parts.length - 1];
    if (/^\d{4}$/.test(last)) return "pos";
    return "title";
  }

  // Optional override: some LVs use dotted codes not ending with 4 digits for positions.
  // We keep the hard "title" rule unless the line clearly has quantity or prices.
  function classifyNrWithOverride(nrTxt, qtyTxt, unitTxt, epTxt, gpTxt){
    const base = classifyNrStrict(nrTxt);
    if (base === "title") {
      const hasQty = parseNumberDE(qtyTxt) !== null;
      const hasPrice = parseNumberDE(epTxt) !== null || parseNumberDE(gpTxt) !== null;
      if (hasQty || hasPrice) return "pos";
    }
    return base;
  }

  // Noise lines detection
  function isNoiseLine(t){
    t = normText(t);
    if(!t) return true;
    const low = t.toLowerCase();
    if (/^seite\s+\d+(\s+von\s+\d+)?$/.test(low)) return true;
    if (low.includes("seite") && low.includes("von")) return true;
    if (low.includes("fortsetzung")) return true;
    if (low.includes("übertrag") || low.includes("uebertrag")) return true;
    if (low.startsWith("datum") && low.includes(":")) return true;
    if (low.startsWith("projekt") && low.includes(":")) return true;
    return false;
  }

  // A conservative "qty-only" check (prevents stealing description numbers like 20cm)
  function looksLikeQtyOnly(t){
    t = normText(t);
    if(!t) return false;
    // Allow: "10", "10,5", "1.234,56", optionally followed by a short unit token
    return /^(\d{1,3}(?:\.\d{3})*(?:,\d+)?|\d+(?:,\d+)?)(\s+[A-Za-zÄÖÜäöüß]{1,10})?$/.test(t);
  }

  // Column cuts: keep defaults, then auto-shrink the Nr column if position codes are far left.
  // Also expose separate buckets for description / qty / unit / ep / gp.
  function getCuts(pageWidth, lines){
    const defaults = {
      nrMax:   pageWidth * 0.26,
      descMax: pageWidth * 0.70,
      qtyMax:  pageWidth * 0.78,
      unitMax: pageWidth * 0.84,
      epMax:   pageWidth * 0.92,
    };

    try{
      if(!lines || !lines.length) return defaults;

      const ends = [];
      const maxScan = Math.min(lines.length, 250);
      for(let i=0;i<maxScan;i++){
        const l = lines[i];
        for(const part of (l.parts || [])){
          const k = classifyNrStrict(part.s);
          if(k === "pos" || k === "title"){
            const endX = (part.x || 0) + (part.w || 0);
            if(endX > 0 && endX < pageWidth) ends.push(endX);
          }
        }
      }

      if(ends.length >= 3){
        ends.sort((a,b)=>a-b);
        const p90 = ends[Math.floor(ends.length * 0.90)];
        const margin = pageWidth * 0.02;

        let nrMax = Math.min(defaults.nrMax, p90 + margin);
        nrMax = Math.max(nrMax, pageWidth * 0.10);

        // Keep space for description: never allow nrMax to invade description too much
        nrMax = Math.min(nrMax, defaults.descMax - pageWidth * 0.10);

        return { ...defaults, nrMax };
      }
    }catch(e){
      // fall back
    }
    return defaults;
  }

  function splitLineByCuts(line, cuts){
    let nr = "", desc = "", qty = "", unit = "", ep = "", gp = "";
    for(const part of line.parts){
      if(part.x <= cuts.nrMax) nr += (nr?" ":"") + part.s;
      else if(part.x <= cuts.descMax) desc += (desc?" ":"") + part.s;
      else if(part.x <= cuts.qtyMax) qty += (qty?" ":"") + part.s;
      else if(part.x <= cuts.unitMax) unit += (unit?" ":"") + part.s;
      else if(part.x <= cuts.epMax) ep += (ep?" ":"") + part.s;
      else gp += (gp?" ":"") + part.s;
    }
    return {
      nr: normText(nr),
      desc: normText(desc),
      qty: normText(qty),
      unit: normText(unit),
      ep: normText(ep),
      gp: normText(gp),
    };
  }

  function renderPreview(rows){
    const header = ["Seite","Pos","Menge","Menge Einheit","EP","GP","Beschreibung"];
    const cols = ["Seite","Pos","Menge","MengeEinheit","EP","GP","Beschreibung"];
    const show = rows.slice(0,50);

    let html = "<thead><tr>" + header.map(h=>"<th>"+h+"</th>").join("") + "</tr></thead><tbody>";
    for(const r of show){
      html += "<tr>" + cols.map(k=>{
        const v = (r[k] == null ? "" : String(r[k]));
        const safe = v.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/\n/g,"<br>");
        return "<td>"+safe+"</td>";
      }).join("") + "</tr>";
    }
    html += "</tbody>";
    elTbl.innerHTML = html;
  }

  async function loadPdf(){
    const f = elFile.files && elFile.files[0];
    if(!f){ alert("Select a PDF file first."); return; }
    if(!window.pdfjsLib){ alert("pdf.min.js not loaded (pdfjsLib missing)."); return; }

    const buf = await f.arrayBuffer();
    pdfDoc = await pdfjsLib.getDocument({data: buf}).promise;

    log("LVtoExcel loaded. VERSION_TAG=" + VERSION_TAG);
    log("PDF loaded. Pages: " + pdfDoc.numPages);
    extractedRows = [];
    renderPreview([]);
    elExtract.disabled = false;
    elExport.disabled = true;
  }

  async function extractLV(){
    if(!pdfDoc){ alert("Load a PDF first."); return; }
    log("Extract started...");

    const out = [];
    let current = null; // keep across pages until a new position begins

    function flush(){
      if(!current) return;
      current.Beschreibung = (current.BeschreibungLines || []).join("\n").trim();
      delete current.BeschreibungLines;
      out.push(current);
      current = null;
    }

    for(let p=1; p<=pdfDoc.numPages; p++){
      const page = await pdfDoc.getPage(p);
      const viewport = page.getViewport({scale: 1.0});
      const pageWidth = viewport.width;

      const content = await page.getTextContent({normalizeWhitespace: false, disableCombineTextItems: false});
      const lines = itemsToLines(content.items);

      const cuts = getCuts(pageWidth, lines);

      for(const line of lines){
        const raw = normText(line.text);
        if(!raw) continue;
        if(isNoiseLine(raw)) continue;

        const parts = splitLineByCuts(line, cuts);

        // Determine if this line starts a new position/title
        const kind = classifyNrWithOverride(parts.nr, parts.qty, parts.unit, parts.ep, parts.gp);

        if(kind === "title"){
          // Title row: only Pos and Beschreibung
          flush();
          const titleDesc = normText([parts.desc, parts.qty, parts.unit, parts.ep, parts.gp].filter(Boolean).join(" "));
          out.push({
            Seite: "",
            Pos: parts.nr,
            Menge: "",
            MengeEinheit: "",
            EP: "",
            GP: "",
            Beschreibung: titleDesc
          });
          continue;
        }

        if(kind === "pos"){
          // New position row
          flush();
          current = {
            Seite: String(p),
            Pos: parts.nr,
            Menge: "",
            MengeEinheit: "",
            EP: "",
            GP: "",
            BeschreibungLines: []
          };

          // Description: keep line breaks by pushing per line
          if(parts.desc && !isNoiseLine(parts.desc)) current.BeschreibungLines.push(parts.desc);

          // Qty + unit (strict buckets)
          const q = parseNumberDE(parts.qty);
          if(q !== null) current.Menge = q;
          if(parts.unit) current.MengeEinheit = parts.unit;

          // Prices
          const ep = parseNumberDE(parts.ep);
          const gp = parseNumberDE(parts.gp);
          if(ep !== null) current.EP = ep;
          if(gp !== null) current.GP = gp;

          continue;
        }

        // Continuation line for the current position
        if(current){
          // Update missing qty/unit if the line looks like it carries qty info
          if((current.Menge === "" || current.Menge === null) && parts.qty){
            if(looksLikeQtyOnly(parts.qty)){
              const q = parseNumberDE(parts.qty);
              if(q !== null) current.Menge = q;
            }
          }
          if((!current.MengeEinheit) && parts.unit){
            // Unit is typically a short token; accept if it is not noise
            if(/^[A-Za-zÄÖÜäöüß]{1,10}$/.test(parts.unit)) current.MengeEinheit = parts.unit;
          }

          // Update missing prices if found
          if((current.EP === "" || current.EP === null) && parts.ep){
            const ep = parseNumberDE(parts.ep);
            if(ep !== null) current.EP = ep;
          }
          if((current.GP === "" || current.GP === null) && parts.gp){
            const gp = parseNumberDE(parts.gp);
            if(gp !== null) current.GP = gp;
          }

          // Append description lines (do not strip numbers like 20cm)
          if(parts.desc && !isNoiseLine(parts.desc)) current.BeschreibungLines.push(parts.desc);

          // Some PDFs put left label column into "qty" bucket; only append if it is clearly not qty-only.
          if(parts.qty && !looksLikeQtyOnly(parts.qty) && !isNoiseLine(parts.qty)) current.BeschreibungLines.push(parts.qty);
          if(parts.unit && !/^[A-Za-zÄÖÜäöüß]{1,10}$/.test(parts.unit) && !isNoiseLine(parts.unit)) current.BeschreibungLines.push(parts.unit);

          continue;
        }
      }
    }

    flush();
    extractedRows = out;

    log("Extract done. Rows: " + extractedRows.length);
    renderPreview(extractedRows);

    elExport.disabled = extractedRows.length === 0;
  }

  function exportXLSX(){
    if(!extractedRows || !extractedRows.length){ alert("Run Extract first."); return; }
    if(!window.XLSX){ alert("xlsx.full.min.js not loaded (XLSX missing)."); return; }

    const header = ["Seite","Pos","Menge","Menge Einheit","EP","GP","Beschreibung"];
    const cols = ["Seite","Pos","Menge","MengeEinheit","EP","GP","Beschreibung"];
    const data = [header, ...extractedRows.map(r => cols.map(k => r[k] ?? ""))];

    const ws = XLSX.utils.aoa_to_sheet(data);
    ws["!cols"] = [
      { wch: 6 },
      { wch: 18 },
      { wch: 10 },
      { wch: 14 },
      { wch: 10 },
      { wch: 10 },
      { wch: 70 },
    ];

    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "LV");

    const out = XLSX.write(wb, { bookType:"xlsx", type:"array" });
    const blob = new Blob([out], {type:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"});

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "LVtoExcel.xlsx";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(a.href);
  }

  elLoad.addEventListener("click", () => loadPdf().catch(e => { console.error(e); alert(String(e)); }));
  elExtract.addEventListener("click", () => extractLV().catch(e => { console.error(e); alert(String(e)); }));
  elExport.addEventListener("click", exportXLSX);

  log("Ready. VERSION_TAG=" + VERSION_TAG);
  </script>
</body>
</html>
