<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LVtoExcel Pro - V4.0 (Header & Types)</title>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    :root { --primary: #0969da; --border:#d0d7de; --bg:#f6f8fa; --white:#ffffff; --danger:#cf222e; }
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 20px; color:#24292f; background:var(--bg); }
    
    .container { max-width: 1280px; margin: 0 auto; display: flex; flex-direction: column; gap: 15px; }
    .card { background: var(--white); border: 1px solid var(--border); border-radius: 6px; padding: 15px; box-shadow: 0 1px 3px rgba(0,0,0,0.04); }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    
    h1 { font-size: 20px; margin: 0; color: var(--primary); }
    .btn { background: #2da44e; color: white; border: 1px solid rgba(27,31,36,0.15); padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 14px; }
    .btn:disabled { background: #94d3a2; cursor: not-allowed; opacity: 0.6; }
    .btn-danger { background: var(--danger); }
    .btn-secondary { background: #f6f8fa; color: #24292f; border-color: var(--border); }
    select, input[type="file"], input[type="text"] { padding: 6px; border-radius: 4px; border: 1px solid var(--border); }

    /* Canvas AlanÄ± */
    #canvasWrapper { position: relative; display: inline-block; border: 1px solid #999; box-shadow: 0 4px 10px rgba(0,0,0,0.1); background: #555; margin-top: 40px; /* Header alanÄ± iÃ§in boÅŸluk */ }
    canvas { display: block; }
    .guide-layer { position: absolute; top: 0; left: 0; cursor: crosshair; z-index: 10; }
    
    /* Header Overlay (Inputs) */
    #headerOverlay {
        position: absolute;
        top: -36px; /* Canvas'Ä±n Ã¼stÃ¼ne Ã§Ä±kar */
        left: 0;
        width: 100%;
        height: 36px;
        pointer-events: none; /* TÄ±klamalar canvas'a geÃ§sin diye, ama inputlar iÃ§in auto yapacaÄŸÄ±z */
        z-index: 20;
        display: none; /* Sadece General Modda gÃ¶rÃ¼nÃ¼r */
    }
    .col-header-box {
        position: absolute;
        top: 0;
        height: 32px;
        background: rgba(255,255,255,0.9);
        border: 1px solid #0969da;
        border-radius: 4px;
        display: flex;
        align-items: center;
        padding: 0 4px;
        pointer-events: auto; /* Inputlara tÄ±klanabilsin */
        box-sizing: border-box;
        gap: 3px;
        transition: left 0.2s, width 0.2s; /* YumuÅŸak geÃ§iÅŸ */
    }
    .col-header-box input { width: 100%; min-width: 30px; font-size: 12px; border:none; background: transparent; font-weight: bold; }
    .col-header-box input:focus { outline: none; background: #eefbff; }
    .col-header-box select { width: 40px; font-size: 11px; border: 1px solid #ccc; background: #eee; cursor: pointer; padding: 0; }

    /* Progress & Preview */
    #progressContainer { width: 100%; display: none; margin-top: 10px; background: #eee; border-radius: 4px; overflow: hidden; }
    #progressBar { width: 0%; height: 5px; background: #2da44e; transition: width 0.3s; }
    #previewArea { overflow-x: auto; max-height: 400px; margin-top: 10px; border: 1px solid var(--border); background: #fff; }
    
    table { width: 100%; border-collapse: collapse; font-size: 12px; }
    th, td { border: 1px solid #ddd; padding: 6px; text-align: left; white-space: pre-wrap; vertical-align: top; }
    th { background: #f0f0f0; position: sticky; top: 0; font-weight: bold; }
    
    .hint { font-size: 12px; color: #666; margin-top: 5px; }
  </style>
</head>
<body>

<div class="container">
  <div class="card row" style="justify-content: space-between;">
    <div class="row">
      <h1>LVtoExcel <span style="font-size:12px; color:#666;">Pro V4.0</span></h1>
      <input type="file" id="fileInput" accept="application/pdf" />
    </div>
    <div class="row">
      <label>Mod:</label>
      <select id="modeSelect">
        <option value="LV">Otomatik LV Modu</option>
        <option value="GENERAL">Manuel Tablo Modu (EditÃ¶r)</option>
      </select>
    </div>
  </div>

  <div class="card" id="controlPanel">
    <div class="row">
      <button id="btnPrev" class="btn btn-secondary">Previous</button>
      <span id="pageInfo">0 / 0</span>
      <button id="btnNext" class="btn btn-secondary">Next</button>
      <div style="flex-grow:1"></div>
      <button id="btnClearGuides" class="btn btn-danger">SÃ¼tunlarÄ± SÄ±fÄ±rla</button>
      <button id="btnExtract" class="btn" disabled>Veriyi Ã‡ek</button>
    </div>
    <div class="hint">
      <span id="guideHint">ðŸ”´ KÄ±rmÄ±zÄ±: Header/Footer Kes | ðŸ”µ Mavi: SÃ¼tun AyracÄ±</span>
      <span id="generalModeHint" style="display:none; color: var(--primary); font-weight:bold;"> :: BoÅŸluÄŸa tÄ±kla: SÃ¼tun Ekle | SaÄŸ tÄ±kla: Sil | Kutucuklara BaÅŸlÄ±k Yaz</span>
    </div>
    <div id="progressContainer"><div id="progressBar"></div></div>
  </div>

  <div style="text-align:center; background:#333; padding:50px 20px 20px 20px; border-radius:8px; overflow:auto;">
    <div id="canvasWrapper">
      <div id="headerOverlay"></div>
      
      <canvas id="the-canvas"></canvas>
      <canvas id="guide-canvas" class="guide-layer"></canvas>
    </div>
  </div>

  <div class="card">
    <div class="row" style="margin-bottom:10px;">
      <h3>Ã–nizleme</h3>
      <div style="flex-grow:1"></div>
      <button id="btnExport" class="btn" style="background:#0969da;" disabled>Excel Ä°ndir (.xlsx)</button>
    </div>
    <div id="previewArea"></div>
  </div>
</div>

<script>
  // STATE
  let pdfDoc = null;
  let pageNum = 1;
  let pdfScale = 1.3;
  let canvas, ctx, guideCanvas, gCtx;
  let extractedData = [];
  
  // VarsayÄ±lan DeÄŸerler
  let extractionMode = "LV"; 
  let guidesLV = { header: 0.1, footer: 0.9, cols: [0.10, 0.50, 0.65, 0.75, 0.85] };
  let guidesGeneral = { header: 0.05, footer: 0.95, cols: [0.2, 0.4, 0.6, 0.8] };
  
  // SÃ¼tun AyarlarÄ± (General Mod Ä°Ã§in)
  // YapÄ±: { index: 0, title: "SÃ¼tun 1", type: "text" }
  let columnSettings = {}; 

  let isDragging = false;
  let dragTarget = null;

  // INIT
  window.addEventListener('DOMContentLoaded', () => {
    canvas = document.getElementById('the-canvas');
    ctx = canvas.getContext('2d');
    guideCanvas = document.getElementById('guide-canvas');
    gCtx = guideCanvas.getContext('2d');
    
    guideCanvas.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    guideCanvas.addEventListener('contextmenu', onRightClick);

    document.getElementById('fileInput').addEventListener('change', handleFileSelect);
    document.getElementById('btnPrev').addEventListener('click', () => renderPage(pageNum - 1));
    document.getElementById('btnNext').addEventListener('click', () => renderPage(pageNum + 1));
    document.getElementById('modeSelect').addEventListener('change', changeMode);
    document.getElementById('btnExtract').addEventListener('click', startExtraction);
    document.getElementById('btnExport').addEventListener('click', exportToExcel);
    document.getElementById('btnClearGuides').addEventListener('click', resetGuides);
  });

  async function handleFileSelect(e) {
    if (!e.target.files[0]) return;
    const ab = await e.target.files[0].arrayBuffer();
    pdfDoc = await pdfjsLib.getDocument(ab).promise;
    document.getElementById('btnExtract').disabled = false;
    renderPage(1);
  }

  async function renderPage(num) {
    if (!pdfDoc || num < 1 || num > pdfDoc.numPages) return;
    pageNum = num;
    document.getElementById('pageInfo').innerText = `${pageNum} / ${pdfDoc.numPages}`;
    
    const page = await pdfDoc.getPage(num);
    const viewport = page.getViewport({ scale: pdfScale });
    
    canvas.width = viewport.width; canvas.height = viewport.height;
    guideCanvas.width = viewport.width; guideCanvas.height = viewport.height;
    
    await page.render({ canvasContext: ctx, viewport: viewport }).promise;
    
    // Header Overlay geniÅŸliÄŸini de ayarla
    document.getElementById('headerOverlay').style.width = viewport.width + "px";
    
    drawGuides();
  }

  function getActiveGuides() { return extractionMode === 'LV' ? guidesLV : guidesGeneral; }

  // --- UI: DRAWING & OVERLAY ---

  function drawGuides() {
    gCtx.clearRect(0, 0, guideCanvas.width, guideCanvas.height);
    const w = guideCanvas.width;
    const h = guideCanvas.height;
    const g = getActiveGuides();

    // Red Areas
    gCtx.fillStyle = "rgba(207, 34, 46, 0.15)";
    gCtx.fillRect(0, 0, w, g.header * h);
    gCtx.fillRect(0, g.footer * h, w, h - (g.footer * h));
    
    gCtx.strokeStyle = "#cf222e"; gCtx.lineWidth = 2;
    gCtx.beginPath(); gCtx.moveTo(0, g.header * h); gCtx.lineTo(w, g.header * h); gCtx.stroke();
    gCtx.beginPath(); gCtx.moveTo(0, g.footer * h); gCtx.lineTo(w, g.footer * h); gCtx.stroke();

    // Blue Columns
    gCtx.strokeStyle = "#0969da";
    gCtx.setLineDash([5, 3]);
    g.cols.forEach(xNorm => {
      const x = xNorm * w;
      gCtx.beginPath(); gCtx.moveTo(x, 0); gCtx.lineTo(x, h); gCtx.stroke();
    });
    gCtx.setLineDash([]);
    
    // Input KutularÄ±nÄ± GÃ¼ncelle (Sadece Mouse BÄ±rakÄ±lÄ±nca veya Mod deÄŸiÅŸince tam render iyidir)
    if (!isDragging) updateHeaderOverlay();
  }

  // Dinamik Input KutularÄ±nÄ± OluÅŸtur (V4.0 Ã–zelliÄŸi)
  function updateHeaderOverlay() {
    const overlay = document.getElementById('headerOverlay');
    
    if (extractionMode !== 'GENERAL') {
      overlay.style.display = 'none';
      return;
    }
    overlay.style.display = 'block';
    
    // Mevcut ayarlarÄ± koru, DOM'u sÄ±fÄ±rdan yap
    // SÃ¼tun aralÄ±klarÄ±nÄ± bul: [0, ...cols, 1]
    const g = getActiveGuides();
    const boundaries = [0, ...g.cols, 1];
    
    // DOM'u temizle ama Ã¶nce inputlardaki deÄŸerleri kaydetsek iyi olurdu. 
    // Basitlik iÃ§in columnSettings objesini kullanacaÄŸÄ±z.
    overlay.innerHTML = "";

    for (let i = 0; i < boundaries.length - 1; i++) {
      const start = boundaries[i];
      const end = boundaries[i+1];
      const widthPct = (end - start) * 100;
      const leftPct = start * 100;
      
      // AyarlarÄ± getir veya varsayÄ±lan yarat
      if (!columnSettings[i]) columnSettings[i] = { title: `SÃ¼tun ${i+1}`, type: 'text' };
      
      const box = document.createElement('div');
      box.className = 'col-header-box';
      box.style.left = leftPct + "%";
      box.style.width = widthPct + "%";
      
      // Input: BaÅŸlÄ±k
      const input = document.createElement('input');
      input.type = "text";
      input.value = columnSettings[i].title;
      input.oninput = (e) => columnSettings[i].title = e.target.value;
      
      // Select: Tip
      const select = document.createElement('select');
      const opts = [
        {val:'text', txt:'T', title:'Metin'}, 
        {val:'number', txt:'#', title:'SayÄ±'}, 
        {val:'currency', txt:'$', title:'Para Birimi'}
      ];
      opts.forEach(o => {
        const op = document.createElement('option');
        op.value = o.val; op.text = o.txt; op.title = o.title;
        if(columnSettings[i].type === o.val) op.selected = true;
        select.appendChild(op);
      });
      select.onchange = (e) => columnSettings[i].type = e.target.value;

      box.appendChild(input);
      box.appendChild(select);
      overlay.appendChild(box);
    }
  }

  // --- INTERACTION ---

  function changeMode() {
    extractionMode = document.getElementById('modeSelect').value;
    document.getElementById('guideHint').style.display = extractionMode === 'LV' ? 'inline' : 'none';
    document.getElementById('generalModeHint').style.display = extractionMode === 'GENERAL' ? 'inline' : 'none';
    // Mod deÄŸiÅŸince ayarlarÄ± temizle veya koru? Temizleyelim kafa karÄ±ÅŸmasÄ±n
    columnSettings = {};
    drawGuides();
  }
  
  function resetGuides() {
    if (extractionMode === 'GENERAL') guidesGeneral.cols = [0.2, 0.4, 0.6, 0.8];
    else guidesLV.cols = [0.10, 0.50, 0.65, 0.75, 0.85];
    columnSettings = {};
    drawGuides();
  }

  function onMouseDown(e) {
    const rect = guideCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const w = guideCanvas.width;
    const h = guideCanvas.height;
    const g = getActiveGuides();

    // Hit test
    if (Math.abs(y - g.header * h) < 10) { isDragging=true; dragTarget='header'; return; }
    if (Math.abs(y - g.footer * h) < 10) { isDragging=true; dragTarget='footer'; return; }
    
    for (let i=0; i<g.cols.length; i++) {
      if (Math.abs(x - g.cols[i] * w) < 10) {
        isDragging=true; dragTarget=i; return;
      }
    }

    if (extractionMode === 'GENERAL' && !isDragging) {
      g.cols.push(x / w);
      g.cols.sort((a,b)=>a-b);
      // Yeni sÃ¼tun eklenince ayarlarÄ± kaydÄ±r veya sÄ±fÄ±rla (Basit Ã§Ã¶zÃ¼m: sÄ±fÄ±rla, Ã§Ã¼nkÃ¼ indexler kaydÄ±)
      columnSettings = {}; 
      drawGuides();
    }
  }

  function onMouseMove(e) {
    if (!isDragging) return;
    const rect = guideCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left; 
    const y = e.clientY - rect.top;
    const w = guideCanvas.width;
    const h = guideCanvas.height;
    const g = getActiveGuides();

    if (dragTarget==='header') g.header = Math.min(y/h, g.footer - 0.05);
    else if (dragTarget==='footer') g.footer = Math.max(y/h, g.header + 0.05);
    else if (typeof dragTarget==='number') g.cols[dragTarget] = Math.max(0, Math.min(x/w, 1));
    
    drawGuides(); // SÃ¼rÃ¼klerken sadece canvas Ã§iz, DOM'u elleme (performans)
  }

  function onMouseUp() {
    if (isDragging) {
      isDragging = false;
      dragTarget = null;
      updateHeaderOverlay(); // SÃ¼rÃ¼kleme bitince kutularÄ± gÃ¼ncelle
    }
  }

  function onRightClick(e) {
    if (extractionMode !== 'GENERAL') return;
    e.preventDefault();
    const rect = guideCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const w = guideCanvas.width;
    const g = getActiveGuides();
    
    const idx = g.cols.findIndex(c => Math.abs(c*w - x) < 15);
    if (idx !== -1) {
      g.cols.splice(idx, 1);
      columnSettings = {}; // Silinince ayarlar bozulmasÄ±n diye sÄ±fÄ±rla
      drawGuides();
    }
  }

  // --- ENGINE ---

  async function startExtraction() {
    if (!pdfDoc) return;
    extractedData = [];
    document.getElementById('progressBar').style.width = "0%";
    const g = getActiveGuides();
    
    for (let i = 1; i <= pdfDoc.numPages; i++) {
      document.getElementById('progressBar').style.width = (i / pdfDoc.numPages * 100) + "%";
      
      const page = await pdfDoc.getPage(i);
      const viewport = page.getViewport({ scale: 1.0 });
      const textContent = await page.getTextContent();
      const [w, h] = [viewport.width, viewport.height];
      
      let items = textContent.items.map(item => {
        const [vx, vy] = viewport.convertToViewportPoint(item.transform[4], item.transform[5]);
        return { str: item.str, x: vx, y: vy, w: item.width };
      });

      // Y Filtresi
      items = items.filter(it => it.y > g.header*h && it.y < g.footer*h);
      items.sort((a,b) => Math.abs(a.y-b.y)<5 ? a.x-b.x : a.y-b.y);

      if (extractionMode === 'LV') processLV(items, w, g.cols);
      else processGeneral(items, w, g.cols);
    }
    
    renderPreview();
    document.getElementById('btnExport').disabled = false;
  }

  function processLV(items, w, cols) {
    let currentRow = null;
    const limits = cols.map(c => c*w);
    
    items.forEach(item => {
      let cIdx = 0;
      for(let i=0; i<limits.length; i++) if(item.x > limits[i]) cIdx = i+1;
      
      if (cIdx===0 && item.str.trim()) {
        if (currentRow) extractedData.push(currentRow);
        currentRow = {c0:item.str, c1:"", c2:"", c3:"", c4:"", c5:""}; // Sabit anahtarlar kullan
      } else if (currentRow) {
        const key = "c" + cIdx;
        if(currentRow[key] !== undefined) currentRow[key] += " " + item.str.trim();
      }
    });
    if (currentRow) extractedData.push(currentRow);
  }

  function processGeneral(items, w, cols) {
    let currentRow = [];
    let lastY = -999;
    const limits = cols.map(c => c*w);
    const colCount = limits.length + 1;
    
    items.forEach(item => {
      if (Math.abs(item.y - lastY) > 10) {
        if (currentRow.length) extractedData.push(currentRow);
        currentRow = new Array(colCount).fill("");
        lastY = item.y;
      }
      
      let cIdx = 0;
      for(let i=0; i<limits.length; i++) if(item.x > limits[i]) cIdx = i+1;
      
      if (currentRow[cIdx]) currentRow[cIdx] += " ";
      currentRow[cIdx] += item.str.trim();
    });
    if (currentRow.length) extractedData.push(currentRow);
  }

  // --- EXPORT ---

  function cleanNum(str) {
    if (!str) return 0;
    let s = str.replace(/[^0-9,.-]/g, '').trim();
    if (s.includes(',') && s.includes('.')) s = s.replace(/\./g,'').replace(',','.');
    else if (s.includes(',')) s = s.replace(',','.');
    return parseFloat(s) || 0;
  }

  function renderPreview() {
    const div = document.getElementById('previewArea');
    div.innerHTML = "";
    const table = document.createElement('table');
    
    // Header Row
    const tr = document.createElement('tr');
    if (extractionMode==='LV') {
      ['Poz No','TanÄ±m','Birim','Miktar','B.Fiyat','Toplam'].forEach(t => {
        const th=document.createElement('th'); th.textContent=t; tr.appendChild(th);
      });
    } else {
      // General Header from Settings
      const colCount = extractedData[0] ? extractedData[0].length : 0;
      for(let i=0; i<colCount; i++) {
        const th = document.createElement('th'); 
        th.textContent = columnSettings[i] ? columnSettings[i].title : `SÃ¼tun ${i+1}`;
        tr.appendChild(th);
      }
    }
    table.appendChild(tr);

    // Data (First 50)
    extractedData.slice(0, 50).forEach(row => {
      const r = document.createElement('tr');
      // LV objesi veya General arrayi normalize et
      const vals = extractionMode==='LV' 
        ? [row.c0, row.c1, row.c2, row.c3, row.c4, row.c5]
        : row;
        
      vals.forEach(v => {
        const d = document.createElement('td'); d.textContent = v; r.appendChild(d);
      });
      table.appendChild(r);
    });
    div.appendChild(table);
  }

  function exportToExcel() {
    const wb = XLSX.utils.book_new();
    let ws_data = [];
    
    // 1. Header OluÅŸtur
    let headers = [];
    if (extractionMode==='LV') {
      headers = ['Poz No','TanÄ±m','Birim','Miktar','Birim Fiyat','Toplam'];
    } else {
      const colCount = extractedData[0] ? extractedData[0].length : 0;
      for(let i=0; i<colCount; i++) {
        headers.push(columnSettings[i] ? columnSettings[i].title : `SÃ¼tun ${i+1}`);
      }
    }
    ws_data.push(headers);

    // 2. Verileri Formatla ve Ekle
    extractedData.forEach(row => {
      let rowData = [];
      if (extractionMode==='LV') {
        const vals = [row.c0, row.c1, row.c2, row.c3, row.c4, row.c5];
        // LV iÃ§in hardcoded tipler (Miktar, Fiyat sayÄ±sal)
        rowData = [
            vals[0], vals[1], vals[2],
            { t:'n', v:cleanNum(vals[3]), z:'#,##0.00' }, // Miktar
            { t:'n', v:cleanNum(vals[4]), z:'#,##0.00 â‚º' }, // Fiyat
            { t:'n', v:cleanNum(vals[5]), z:'#,##0.00 â‚º' }  // Toplam
        ];
      } else {
        // General Mod: KullanÄ±cÄ±nÄ±n seÃ§tiÄŸi tiplere gÃ¶re
        const vals = row;
        rowData = vals.map((val, idx) => {
          const type = columnSettings[idx] ? columnSettings[idx].type : 'text';
          if (type === 'number') {
            return { t:'n', v:cleanNum(val), z:'0.00' };
          } else if (type === 'currency') {
            return { t:'n', v:cleanNum(val), z:'#,##0.00 â‚º' }; // TRY formatÄ±
          } else {
            return val; // Text
          }
        });
      }
      ws_data.push(rowData);
    });

    const ws = XLSX.utils.aoa_to_sheet(ws_data);
    XLSX.utils.book_append_sheet(wb, ws, "Veriler");
    
    const wbout = XLSX.write(wb, {bookType:'xlsx', type:'array'});
    const blob = new Blob([wbout], {type:"application/octet-stream"});
    const url = window.URL.createObjectURL(blob);
    
    const a = document.createElement("a");
    a.href = url;
    a.download = "Tablo_Export.xlsx";
    a.click();
  }
</script>
</body>
</html>
