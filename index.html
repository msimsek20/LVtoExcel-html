<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LVtoExcel</title>
  <style>
    body{font-family:system-ui,Arial,sans-serif;margin:0}
    .wrap{display:grid;grid-template-columns:460px 1fr;gap:12px;height:100vh}
    .panel{padding:12px;border-right:1px solid #ddd;overflow:auto}
    .viewer{padding:12px;overflow:auto}
    label{display:block;font-size:12px;margin-top:10px;color:#333}
    input,button{width:100%;box-sizing:border-box;padding:8px;margin-top:6px}
    .btnrow{display:flex;gap:8px;margin-top:10px}
    .btnrow button{flex:1}
    canvas{border:1px solid #ccc;max-width:100%;height:auto}
    pre{height:230px;overflow:auto;border:1px solid #ccc;background:#fff;padding:8px}
    .hint{font-size:12px;color:#666;margin-top:6px}
    h1{font-size:22px;margin:0 0 8px 0}
  </style>

  <!-- Local copies (NO CDN) -->
  <script src="./pdf.min.js"></script>
  <script src="./xlsx.full.min.js"></script>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h1>LVtoExcel</h1>
    <div class="hint">
      Runs fully in your browser (no upload). Keep these files in the same folder:
      <b>index.html</b>, <b>pdf.min.js</b>, <b>pdf.worker.min.js</b>, <b>xlsx.full.min.js</b>.
    </div>

    <label>Select PDF</label>
    <input id="pdfFile" type="file" accept="application/pdf" />

    <div class="btnrow">
      <button id="loadBtn">Load PDF</button>
      <button id="extractBtn">Extract LV</button>
    </div>

    <div class="btnrow">
      <button id="xlsxBtn">Export XLSX</button>
      <button id="csvBtn">Export CSV</button>
    </div>

    <label>Log</label>
    <pre id="log"></pre>
  </div>

  <div class="viewer">
    <canvas id="canvas"></canvas>
    <div id="out"></div>
  </div>
</div>

<script>
// Set this manually when you publish a new version.
const VERSION_TAG = "20251217_1500";
const VERSION = `LVtoExcel v${VERSION_TAG}`;

let pdfDoc = null;
let extractedRows = null;

const logEl = document.getElementById("log");
function log(msg){ logEl.textContent += msg + "\n"; logEl.scrollTop = logEl.scrollHeight; }

log(`Welcome! ${VERSION}`);
log("Tip: Use Ctrl+F5 if you replaced index.html (browser cache).");

document.getElementById("loadBtn").addEventListener("click", loadPdf);
document.getElementById("extractBtn").addEventListener("click", extractLV);
document.getElementById("csvBtn").addEventListener("click", exportCSV);
document.getElementById("xlsxBtn").addEventListener("click", exportXLSX);

// PDF.js worker (required for stable operation on HTTPS)
if (window.pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
  pdfjsLib.GlobalWorkerOptions.workerSrc = "./pdf.worker.min.js";
} else {
  log("ERROR: pdf.min.js not loaded (pdfjsLib missing).");
}

async function loadPdf(){
  try{
    log("loadPdf() ...");
    if(!window.pdfjsLib) throw new Error("pdf.min.js not loaded (pdfjsLib missing).");
    const f = document.getElementById("pdfFile").files[0];
    if(!f) { alert("Please select a PDF first."); return; }
    const buf = await f.arrayBuffer();
    log("PDF size: " + (buf.byteLength/1024/1024).toFixed(2) + " MB");

    const loadingTask = pdfjsLib.getDocument({
      data: buf,
      disableFontFace: true,
      useSystemFonts: true,
      isEvalSupported: false,
      stopAtErrors: false,
    });

    loadingTask.onProgress = (p)=>{
      try{
        if(p && p.total){
          const pct = Math.round((p.loaded/p.total)*100);
          log("Loading: " + pct + "%");
        }
      }catch(e){}
    };

    pdfDoc = await loadingTask.promise;
    log("PDF loaded. Pages: " + pdfDoc.numPages);

    await renderPage(1);
    log("Rendered page 1.");
  }catch(e){
    log("ERROR: " + (e && e.message ? e.message : e));
    alert("Error: " + (e && e.message ? e.message : e));
  }
}

async function renderPage(pno){
  const page = await pdfDoc.getPage(pno);
  const vp = page.getViewport({ scale: 1.5 });
  const canvas = document.getElementById("canvas");
  canvas.width = Math.floor(vp.width);
  canvas.height = Math.floor(vp.height);
  await page.render({ canvasContext: canvas.getContext("2d"), viewport: vp }).promise;
}

function normText(s){
  return (s||"").replace(/\s+/g," ").trim();
}

function parseNumberDE(s){
  s = normText(s);
  if(!s) return null;
  s = s.replace(/[^0-9,\.\-]/g,"");
  if(!s) return null;
  if(s.indexOf(",") >= 0){
    s = s.replace(/\./g,"").replace(",", ".");
  }
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}

function itemsToLines(items){
  const pts = items
    .map(it => ({ x: it.transform[4], y: it.transform[5], s: normText(it.str) }))
    .filter(p => p.s);

  pts.sort((a,b)=> (b.y-a.y) || (a.x-b.x));

  const lines = [];
  const yTol = 2.2;
  for(const p of pts){
    let line = lines.find(l => Math.abs(l.y - p.y) <= yTol);
    if(!line){
      line = { y: p.y, parts: [] };
      lines.push(line);
    }
    line.parts.push({x:p.x, s:p.s});
  }

  for(const l of lines){
    l.parts.sort((a,b)=>a.x-b.x);
    l.text = l.parts.map(pp=>pp.s).join(" ").trim();
  }

  lines.sort((a,b)=>b.y-a.y);
  return lines;
}

// Conservative cuts. Many LVs place Qty/Unit wider than expected.
function getCuts(pageWidth){
  return {
    nrMax: pageWidth * 0.26,
    qtyMax: pageWidth * 0.72,
    epMax: pageWidth * 0.87,
  };
}

// "pos": ends with 4 digits, e.g. 1.012.01.0010
// "title": any dotted numeric string not ending with 4 digits
function classifyNr(s){
  s = normText(s);
  if(!s) return null;
  if(!/^\d[\d\.]*\d$/.test(s)) return null;
  if(s.indexOf(".") === -1) return null;

  const parts = s.split(".");
  const last = parts[parts.length-1];
  if(/^\d{4}$/.test(last)) return "pos";
  return "title";
}

// Footer/noise detection (not shown to user)
function isNoiseLine(t){
  t = normText(t||"");
  if(!t) return true;
  const NOISE = [
    /Fortsetzung/i,
    /nächster\s+Seite/i,
    /\bÜbertrag\b/i,
    /Seite\s+\d+\s+von\s+\d+/i
  ];
  return NOISE.some(rx => rx.test(t));
}

function escapeHtml(s){
  return String(s||"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
}

// Try to pull "quantity + unit" from a text chunk (German number formats)
function extractQtyUnit(text){
  const t = normText(text);
  if(!t) return { qty:null, unit:null, cleaned:t };

  const rx = /(\d{1,3}(?:\.\d{3})*(?:,\d+)?|\d+(?:,\d+)?)\s*([A-Za-zÄÖÜäöüß]{1,10})\b/g;
  let m, last = null;
  while((m = rx.exec(t)) !== null){
    const unit = m[2];
    if(/^EP$/i.test(unit) || /^GP$/i.test(unit)) continue;
    last = { qtyStr: m[1], unit: unit, idx: m.index, len: m[0].length };
  }
  if(!last) return { qty:null, unit:null, cleaned:t };

  const qty = parseNumberDE(last.qtyStr);
  const unit = last.unit;
  const cleaned = normText((t.slice(0,last.idx) + " " + t.slice(last.idx + last.len)).trim());
  return { qty, unit, cleaned };
}

async function extractLV(){
  try{
    if(!pdfDoc){ alert("Load a PDF first."); return; }
    log("extractLV() ...");

    const out = [];
    let current = null; // keep across pages (for continued items)

    function flush(){
      if(current){
        current.Beschreibung = (current.BeschreibungLines || []).join("\n").trim();
        delete current.BeschreibungLines;
        out.push(current);
        current = null;
      }
    }

    for(let p=1;p<=pdfDoc.numPages;p++){
      const page = await pdfDoc.getPage(p);
      const vp = page.getViewport({ scale: 1.0 });
      const width = vp.width;

      const tc = await page.getTextContent();
      const lines = itemsToLines(tc.items);

      // Detect LV pages by presence of position numbers (even if header is missing on continuation pages)
      const joined = lines.slice(0,80).map(l=>l.text).join(" | ");
      const hasPosPattern = /\d+(?:\.\d+)+\.\d{4}\b/.test(joined);
      const hasTableHeader = /\bNr\.?\b/i.test(joined) && /Menge\/Einheit/i.test(joined);
      if(!hasPosPattern && !hasTableHeader) continue;

      const cuts = getCuts(width);

      for(const l of lines){
        if(isNoiseLine(l.text)) continue;

        let nrTxt = "";
        let qtyTxt = "";
        let epTxt = "";
        let gpTxt = "";

        for(const part of l.parts){
          if(part.x <= cuts.nrMax) nrTxt += (nrTxt?" ":"") + part.s;
          else if(part.x <= cuts.qtyMax) qtyTxt += (qtyTxt?" ":"") + part.s;
          else if(part.x <= cuts.epMax) epTxt += (epTxt?" ":"") + part.s;
          else gpTxt += (gpTxt?" ":"") + part.s;
        }

        nrTxt = normText(nrTxt);
        qtyTxt = normText(qtyTxt);
        epTxt = normText(epTxt);
        gpTxt = normText(gpTxt);

        const headerish = /\bNr\b/i.test(nrTxt) || /Menge\/Einheit/i.test(qtyTxt) || /^EP$/i.test(epTxt) || /^GP$/i.test(gpTxt);
        if(headerish) continue;

        const kind = classifyNr(nrTxt);

        // Title line
        if(kind === "title"){
          flush();
          let after = normText(l.text.replace(nrTxt, ""));
          if(after && !isNoiseLine(after)){
            out.push({
              Seite: p,
              Pos: nrTxt,
              Menge: "",
              MengeEinheit: "",
              EP: "",
              GP: "",
              Beschreibung: after
            });
          }
          continue;
        }

        // New position line
        if(kind === "pos"){
          flush();

          current = {
            Seite: p,
            Pos: nrTxt,
            Menge: "",
            MengeEinheit: "",
            EP: "",
            GP: "",
            BeschreibungLines: []
          };

          const ep = parseNumberDE(epTxt);
          const gp = parseNumberDE(gpTxt);
          if(ep !== null) current.EP = ep;
          if(gp !== null) current.GP = gp;

          const midParts = l.parts.filter(pt => pt.x > cuts.nrMax && pt.x <= cuts.epMax);
          let midText = normText(midParts.map(pt=>pt.s).join(" "));
          if(midText && !isNoiseLine(midText)){
            if(qtyTxt){
              const q = extractQtyUnit(qtyTxt);
              if(q.qty !== null) current.Menge = q.qty;
              if(q.unit) current.MengeEinheit = q.unit;

              const q2 = extractQtyUnit(midText);
              if(q2.qty !== null && current.Menge === "") current.Menge = q2.qty;
              if(q2.unit && !current.MengeEinheit) current.MengeEinheit = q2.unit;
              midText = q2.cleaned;
            }else{
              const q = extractQtyUnit(midText);
              if(q.qty !== null) current.Menge = q.qty;
              if(q.unit) current.MengeEinheit = q.unit;
              midText = q.cleaned;
            }

            if(midText){
              current.BeschreibungLines.push(midText);
            }
          }

          continue;
        }

        // Continuation line
        if(current){
          if(current.EP === "" || current.EP === null){
            const ep = parseNumberDE(epTxt);
            if(ep !== null) current.EP = ep;
          }
          if(current.GP === "" || current.GP === null){
            const gp = parseNumberDE(gpTxt);
            if(gp !== null) current.GP = gp;
          }

          if((current.Menge === "" || current.Menge === null) || !current.MengeEinheit){
            if(qtyTxt){
              const q = extractQtyUnit(qtyTxt);
              if(q.qty !== null && (current.Menge === "" || current.Menge === null)) current.Menge = q.qty;
              if(q.unit && !current.MengeEinheit) current.MengeEinheit = q.unit;
            }
          }

          const midParts = l.parts.filter(pt => pt.x > cuts.nrMax && pt.x <= cuts.epMax);
          let midText = normText(midParts.map(pt=>pt.s).join(" "));
          if(midText && !isNoiseLine(midText)){
            const q = extractQtyUnit(midText);
            midText = q.cleaned;

            if(midText){
              current.BeschreibungLines.push(midText);
            }
          }
        }
      }
    }

    flush();
    extractedRows = out;

    log("Done. Rows: " + out.length);

    let html = "<table border='1' style='border-collapse:collapse;font-size:12px'>";
    html += "<tr><th>Seite</th><th>Pos</th><th>Menge</th><th>Menge Einheit</th><th>EP</th><th>GP</th><th>Beschreibung</th></tr>";
    out.slice(0,50).forEach(r=>{
      html += "<tr>" +
        "<td>"+(r.Seite ?? "")+"</td>"+
        "<td>"+escapeHtml(r.Pos ?? "")+"</td>"+
        "<td>"+(r.Menge ?? "")+"</td>"+
        "<td>"+escapeHtml(r.MengeEinheit ?? "")+"</td>"+
        "<td>"+(r.EP ?? "")+"</td>"+
        "<td>"+(r.GP ?? "")+"</td>"+
        "<td style='white-space:pre-wrap'>"+escapeHtml((r.Beschreibung||"").slice(0,400))+"</td>"+
      "</tr>";
    });
    html += "</table><div class='hint'>Showing first 50 rows. Use Export to download all.</div>";
    document.getElementById("out").innerHTML = html;

  }catch(e){
    log("ERROR: " + (e && e.message ? e.message : e));
    alert("Error: " + (e && e.message ? e.message : e));
  }
}

function exportCSV(){
  if(!extractedRows || !extractedRows.length){ alert("Run Extract first."); return; }
  const cols = ["Seite","Pos","Menge","MengeEinheit","EP","GP","Beschreibung"];
  const header = ["Seite","Pos","Menge","Menge Einheit","EP","GP","Beschreibung"];
  const esc = (v)=>(''+(v??'')).replace(/"/g,'""');
  const csv = header.join(",") + "\n" + extractedRows.map(r =>
    cols.map(c => `"${esc(r[c])}"`).join(",")
  ).join("\n");
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([csv], {type:"text/csv;charset=utf-8"}));
  a.download = `LVtoExcel_${VERSION_TAG}.csv`;
  a.click();
}

function exportXLSX(){
  if(!extractedRows || !extractedRows.length){ alert("Run Extract first."); return; }
  if(!window.XLSX){ alert("xlsx.full.min.js not loaded (XLSX missing)."); return; }

  const header = ["Seite","Pos","Menge","Menge Einheit","EP","GP","Beschreibung"];
  const cols = ["Seite","Pos","Menge","MengeEinheit","EP","GP","Beschreibung"];
  const data = [header, ...extractedRows.map(r => cols.map(k => r[k] ?? ""))];

  const ws = XLSX.utils.aoa_to_sheet(data);
  ws["!cols"] = [
    { wch: 6 },
    { wch: 18 },
    { wch: 10 },
    { wch: 14 },
    { wch: 10 },
    { wch: 10 },
    { wch: 80 },
  ];

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "LV");
  XLSX.writeFile(wb, `LVtoExcel_${VERSION_TAG}.xlsx`);
}
</script>
</body>
</html>
