<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LVtoExcel (browser-only)</title>
  <style>
    :root { --border:#d0d7de; --bg:#ffffff; --muted:#57606a; --shadow:0 1px 2px rgba(0,0,0,.06); }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 18px; color:#111; background:var(--bg); }
    h1 { font-size: 20px; margin: 0 0 8px 0; }
    .sub { color: var(--muted); font-size: 13px; margin-bottom: 14px; }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items:center; }
    .card { border:1px solid var(--border); border-radius: 10px; padding: 12px; box-shadow: var(--shadow); background:#fff; }
    .btn { border:1px solid var(--border); background:#f6f8fa; padding: 8px 12px; border-radius: 8px; cursor:pointer; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    input[type="file"] { padding: 6px; }
    .tiny { font-size: 12px; color: var(--muted); }
    textarea { width:100%; height: 160px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; padding: 10px; border-radius: 10px; border:1px solid var(--border); }
    table { width:100%; border-collapse: collapse; font-size: 12px; }
    th, td { border:1px solid var(--border); padding: 6px 8px; vertical-align: top; }
    th { background:#f6f8fa; position: sticky; top: 0; z-index: 1; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 1100px) { .grid { grid-template-columns: 520px 1fr; } }
    .canvasWrap { position: relative; border:1px solid var(--border); border-radius: 10px; overflow: hidden; background:#fff; }
    canvas { width:100%; height:auto; display:block; }
    .overlay { position:absolute; inset:0; pointer-events:none; }
    .guide { position:absolute; top:0; bottom:0; width:2px; background: rgba(255,0,0,0.75); pointer-events:auto; cursor: ew-resize; }
    .guideLabel { position:absolute; top:6px; transform: translateX(-50%); background: rgba(255,255,255,0.92); border:1px solid var(--border); border-radius: 8px; padding: 2px 6px; font-size: 11px; color:#111; pointer-events:none; }
    .kpi { display:flex; gap:10px; flex-wrap:wrap; }
    .pill { border:1px solid var(--border); border-radius:999px; padding:4px 8px; font-size:12px; background:#fff; }
    .warn { color:#b54708; }
  </style>
</head>
<body>
  <h1>LVtoExcel (browser-only)</h1>
  <div class="sub">Loads local <b>pdf.min.js</b>, <b>pdf.worker.min.js</b>, <b>xlsx.full.min.js</b> from the same folder.</div>

  <div class="card">
    <div class="row" style="margin-bottom:8px;">
      <input id="fileInput" type="file" accept="application/pdf" />
      <button id="btnLoad" class="btn" disabled>Load PDF</button>
      <button id="btnExtract" class="btn" disabled>Extract</button>
      <button id="btnExport" class="btn" disabled>Export XLSX</button>
      <div class="tiny">Output columns: Seite | Pos | Menge | Menge Einheit | EP | GP | Beschreibung</div>
    </div>

    <div class="row" style="gap:18px; margin-top:6px;">
      <div class="row" style="gap:8px;">
        <button id="btnPrev" class="btn" disabled>◀ Page</button>
        <button id="btnNext" class="btn" disabled>Page ▶</button>
        <span class="tiny" id="pageInfo">No PDF loaded</span>
      </div>

      <div class="row" style="gap:10px;">
        <label class="tiny"><input type="checkbox" id="chkCalib" /> Enable calibration guides</label>
        <button id="btnSavePreset" class="btn" disabled>Save preset</button>
        <button id="btnClearPreset" class="btn" disabled>Clear preset</button>
        <span class="tiny" id="presetInfo"></span>
      </div>
    </div>

    <div class="kpi" style="margin-top:8px;">
      <span class="pill" id="kpiVersion"></span>
      <span class="pill" id="kpiMode"></span>
      <span class="pill" id="kpiCols"></span>
    </div>
  </div>

  <div class="grid" style="margin-top:12px;">
    <div class="card">
      <div style="display:flex; justify-content: space-between; align-items:center; margin-bottom:8px;">
        <div><b>PDF preview</b> <span class="tiny">(always available after Load PDF)</span></div>
        <div class="tiny warn" id="previewWarn"></div>
      </div>
      <div class="canvasWrap" id="canvasWrap">
        <canvas id="pdfCanvas"></canvas>
        <div class="overlay" id="overlay"></div>
      </div>
      <div class="tiny" style="margin-top:8px;">
        Calibration guides split the page into columns (Pos | Qty | Unit | EP | GP | Desc). Drag red lines when enabled.
      </div>
    </div>

    <div class="card">
      <b>Log</b>
      <textarea id="log" readonly></textarea>
      <div style="height:10px;"></div>
      <b>Preview (first 50 rows)</b>
      <div style="max-height: 360px; overflow:auto; border:1px solid var(--border); border-radius:10px; margin-top:8px;">
        <table id="tbl">
          <thead>
            <tr>
              <th>Seite</th>
              <th>Pos</th>
              <th>Menge</th>
              <th>Menge Einheit</th>
              <th>EP</th>
              <th>GP</th>
              <th>Beschreibung</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Local dependencies (must be in same folder) -->
  <script src="./pdf.min.js"></script>
  <script>
    // pdf.js worker must be local, same folder.
    pdfjsLib.GlobalWorkerOptions.workerSrc = "./pdf.worker.min.js";
  </script>
  <script src="./xlsx.full.min.js"></script>

  <script>
    // =========================
    // Versioning
    // =========================
    const VERSION_TAG = "20251218_1140";

    // =========================
    // State
    // =========================
    let pdfDoc = null;
    let currentPage = 1;
    let fileMetaKey = null;
    let extractedRows = [];
    let preset = null;            // { boundariesNorm: number[] }
    let sessionGuides = null;     // { boundariesNorm: number[] } (not persisted)
    let autoModel = null;         // { boundariesNorm, centers, assignmentMode }

    // 6 columns split by 5 vertical boundaries:
    // [posEnd, qtyEnd, unitEnd, epEnd, gpEnd] normalized to [0..1]
    const DEFAULT_BOUNDARIES = [0.22, 0.34, 0.44, 0.60, 0.72];

    // =========================
    // UI Helpers
    // =========================
    const $ = (id) => document.getElementById(id);
    function log(msg) {
      const ta = $("log");
      ta.value += msg + "\n";
      ta.scrollTop = ta.scrollHeight;
    }
    function setKpi() {
      $("kpiVersion").textContent = "VERSION_TAG=" + VERSION_TAG;
      const mode =
        (sessionGuides && sessionGuides.boundariesNorm) ? "Mode: Session guides" :
        (preset && preset.boundariesNorm) ? "Mode: Preset boundaries" :
        "Mode: Auto clustering";
      $("kpiMode").textContent = mode;
      const b =
        (sessionGuides && sessionGuides.boundariesNorm) ? sessionGuides.boundariesNorm :
        (preset && preset.boundariesNorm) ? preset.boundariesNorm :
        (autoModel ? autoModel.boundariesNorm : DEFAULT_BOUNDARIES);
      $("kpiCols").textContent = "Boundaries: " + b.map(v => v.toFixed(2)).join(", ");
    }
    function clearTable() {
      $("tbl").querySelector("tbody").innerHTML = "";
    }
    function renderTable(rows) {
      const tbody = $("tbl").querySelector("tbody");
      tbody.innerHTML = "";
      const show = rows.slice(0, 50);
      for (const r of show) {
        const tr = document.createElement("tr");
        const cols = ["Seite","Pos","Menge","Menge Einheit","EP","GP","Beschreibung"];
        for (const c of cols) {
          const td = document.createElement("td");
          td.textContent = (r[c] ?? "");
          if (c === "Beschreibung") td.style.whiteSpace = "pre-wrap";
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
    }

    // =========================
    // Preset storage
    // =========================
    function makeFileKey(file) {
      return "LVtoExcel:preset:" + [file.name, file.size, file.lastModified].join("|");
    }
    function loadPresetForFile() {
      if (!fileMetaKey) return null;
      try {
        const raw = localStorage.getItem(fileMetaKey);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (obj && Array.isArray(obj.boundariesNorm) && obj.boundariesNorm.length === 5) return obj;
      } catch (_) {}
      return null;
    }
    function savePresetForFile(boundariesNorm) {
      if (!fileMetaKey) return;
      const obj = { boundariesNorm };
      localStorage.setItem(fileMetaKey, JSON.stringify(obj));
      preset = obj;
      updatePresetUI();
      setKpi();
      log("Preset saved.");
    }
    function clearPresetForFile() {
      if (!fileMetaKey) return;
      localStorage.removeItem(fileMetaKey);
      preset = null;
      updatePresetUI();
      setKpi();
      log("Preset cleared.");
    }
    function updatePresetUI() {
      if (!fileMetaKey) {
        $("presetInfo").textContent = "";
        $("btnSavePreset").disabled = true;
        $("btnClearPreset").disabled = true;
        return;
      }
      preset = loadPresetForFile();
      if (preset) {
        $("presetInfo").textContent = "Preset loaded for this PDF.";
        $("btnClearPreset").disabled = false;
      } else {
        $("presetInfo").textContent = "No preset for this PDF.";
        $("btnClearPreset").disabled = true;
      }
      $("btnSavePreset").disabled = !$("chkCalib").checked;
    }

    // =========================
    // PDF Preview (independent of extraction)
    // =========================
    async function renderCurrentPage() {
      if (!pdfDoc) return;
      const page = await pdfDoc.getPage(currentPage);
      const viewport = page.getViewport({ scale: 1.6 });

      const canvas = $("pdfCanvas");
      const ctx = canvas.getContext("2d");
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);

      $("previewWarn").textContent = "";
      const renderTask = page.render({ canvasContext: ctx, viewport });
      await renderTask.promise;

      $("pageInfo").textContent = `Page ${currentPage} / ${pdfDoc.numPages}`;

      // Recompute auto model for this page and update guides (unless user is actively calibrating).
      try {
        const textContent = await page.getTextContent();
        autoModel = buildAutoColumnModel(textContent, viewport.width);
        const active = getActiveBoundariesNormForPreview();
        applyGuides(active);
      } catch (e) {
        $("previewWarn").textContent = "Preview model warning: " + (e?.message || String(e));
      }
      setKpi();
    }

    // =========================
    // Calibration guides
    // =========================
    const GUIDE_NAMES = ["Pos", "Qty", "Unit", "EP", "GP"];
    let guides = []; // {el,labelEl,idx,normX}

    function overlayRect() {
      return $("pdfCanvas").getBoundingClientRect();
    }

    function getActiveBoundariesNormForPreview() {
      if ($("chkCalib").checked && sessionGuides && sessionGuides.boundariesNorm) return sessionGuides.boundariesNorm;
      if (preset && preset.boundariesNorm) return preset.boundariesNorm;
      if (autoModel && autoModel.boundariesNorm) return autoModel.boundariesNorm;
      return DEFAULT_BOUNDARIES;
    }

    function applyGuides(boundariesNorm) {
      const overlay = $("overlay");
      overlay.innerHTML = "";
      guides = [];
      const rect = overlayRect();
      const w = rect.width || 1;

      boundariesNorm.forEach((nx, idx) => {
        const x = nx * w;

        const line = document.createElement("div");
        line.className = "guide";
        line.style.left = `${x}px`;

        const label = document.createElement("div");
        label.className = "guideLabel";
        label.style.left = `${x}px`;
        label.textContent = GUIDE_NAMES[idx];

        overlay.appendChild(line);
        overlay.appendChild(label);

        guides.push({ el: line, labelEl: label, idx, normX: nx });
      });

      setGuidesEnabled($("chkCalib").checked);
      attachGuideDrag();
    }

    function setGuidesEnabled(enabled) {
      for (const g of guides) {
        g.el.style.display = enabled ? "block" : "none";
        g.labelEl.style.display = enabled ? "block" : "none";
      }
      $("btnSavePreset").disabled = !enabled;
    }

    function getBoundariesFromGuides() {
      const arr = guides.map(g => g.normX).slice();
      const clamped = arr.map(v => Math.max(0.05, Math.min(0.95, v)));
      clamped.sort((a,b)=>a-b);
      const minGap = 0.03;
      for (let i=1;i<clamped.length;i++) {
        if (clamped[i] - clamped[i-1] < minGap) clamped[i] = clamped[i-1] + minGap;
      }
      for (let i=0;i<clamped.length;i++) clamped[i] = Math.max(0.05, Math.min(0.95, clamped[i]));
      return clamped;
    }

    function attachGuideDrag() {
      for (const g of guides) {
        g.el.onpointerdown = (ev) => {
          if (!$("chkCalib").checked) return;
          ev.preventDefault();
          g.el.setPointerCapture(ev.pointerId);

          const move = (e) => {
            const rect = overlayRect();
            const x = e.clientX - rect.left;
            const nx = x / Math.max(1, rect.width);
            g.normX = Math.max(0.02, Math.min(0.98, nx));
            const px = g.normX * rect.width;
            g.el.style.left = `${px}px`;
            g.labelEl.style.left = `${px}px`;
          };

          const up = () => {
            const b = getBoundariesFromGuides();
            // Session-only guide override (until saved)
            sessionGuides = { boundariesNorm: b };
            applyGuides(b);
            setKpi();
          };

          g.el.onpointermove = move;
          g.el.onpointerup = up;
        };
      }
    }

    // =========================
    // Auto Column Model (x clustering)
    // =========================
    function clamp01(v){ return Math.max(0, Math.min(1, v)); }

    function snapToGap(x, centers, pageWidth) {
      if (!centers || centers.length < 2) return x;
      let best = x, bestDist = Infinity;
      for (let i=0;i<centers.length-1;i++) {
        const mid = (centers[i] + centers[i+1]) * 0.5;
        const dist = Math.abs(mid - x);
        if (dist < bestDist) { bestDist = dist; best = mid; }
      }
      return Math.max(pageWidth*0.05, Math.min(pageWidth*0.95, best));
    }

    function buildAutoColumnModel(textContent, pageWidthPx) {
      const xs = [];
      const items = textContent.items || [];
      for (const it of items) {
        const s = (it.str || "").trim();
        if (!s) continue;
        const x = it.transform[4];
        const w = it.width || 0;
        xs.push(x + w * 0.5);
      }
      if (xs.length < 30) {
        return { boundariesNorm: DEFAULT_BOUNDARIES.slice(), centers: [], assignmentMode: "fallback" };
      }

      xs.sort((a,b)=>a-b);

      // Greedy 1D clustering
      const clusters = [];
      const threshold = Math.max(10, pageWidthPx * 0.02);
      let cur = [xs[0]];
      for (let i=1;i<xs.length;i++) {
        if (xs[i] - xs[i-1] <= threshold) cur.push(xs[i]);
        else { clusters.push(cur); cur = [xs[i]]; }
      }
      clusters.push(cur);

      const centers = clusters.map(c => c.reduce((a,b)=>a+b,0)/c.length).sort((a,b)=>a-b);

      // Keep densest clusters
      let keep = clusters.map((c, idx)=>({ idx, count:c.length, center: centers[idx] }));
      keep.sort((a,b)=>b.count-a.count);
      keep = keep.slice(0, Math.min(10, keep.length));
      keep.sort((a,b)=>a.center-b.center);
      const keptCenters = keep.map(k=>k.center);

      // Quantile cuts snapped to gaps
      const q = (p) => xs[Math.floor((xs.length-1)*p)];
      const quant = [q(0.18), q(0.32), q(0.44), q(0.62), q(0.78)];
      const boundariesPx = quant.map(v => snapToGap(v, keptCenters, pageWidthPx));
      const boundariesNorm = boundariesPx.map(v => clamp01(v / Math.max(1, pageWidthPx)));

      // Enforce ordering and minimum gaps
      boundariesNorm.sort((a,b)=>a-b);
      const minGap = 0.03;
      for (let i=1;i<boundariesNorm.length;i++) {
        if (boundariesNorm[i] - boundariesNorm[i-1] < minGap) boundariesNorm[i] = boundariesNorm[i-1] + minGap;
      }
      for (let i=0;i<boundariesNorm.length;i++) boundariesNorm[i] = clamp01(boundariesNorm[i]);

      return { boundariesNorm, centers: keptCenters, assignmentMode: "auto" };
    }

    // =========================
    // Parsing primitives (token-based, robust)
    // =========================
    function escapeRegex(s) {
      return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function normalizeSpaces(s) {
      return (s || "").replace(/\s+/g, " ").trim();
    }

    function stripOuterPunct(token) {
      let t = (token || "").trim();
      // Remove leading/trailing punctuation but keep dots inside codes.
      t = t.replace(/^[\(\[\{<]+/, "").replace(/[\)\]\}>]+$/, "");
      t = t.replace(/^[,:;]+/, "").replace(/[,:;]+$/, "");
      return t;
    }

    function isDottedNumericCode(t) {
      const s = t.trim();
      return /^\d+(?:\.\d+)+$/.test(s);
    }

    function endsWithFourDigits(code) {
      return /\.\d{4}$/.test(code);
    }

    function isPosToken(token) {
      const t = token.trim();
      if (!t) return false;
      if (isDottedNumericCode(t)) return true;
      if (/^\d{1,6}$/.test(t)) return true;
      if (/^[A-Z]\d{1,3}(?:[.-]\d{1,4})+$/i.test(t)) return true;
      return false;
    }

    function isTitleCode(code) {
      // Title/Section rule: dotted numeric code but NOT ending with 4 digits
      if (!isDottedNumericCode(code)) return false;
      return !endsWithFourDigits(code);
    }

    function parseMoneyToken(token) {
      // Accept 2-3 decimals, optional currency symbol, thousands separators.
      if (!token) return null;
      let t = token.replace(/\s+/g, "");
      // Remove common currency marks without hardcoding any language words.
      t = t.replace(/[€$£]/g, "");
      // Must contain digits
      if (!/\d/.test(t)) return null;

      // If both dot and comma exist: assume dot thousands, comma decimal.
      if (t.includes(".") && t.includes(",")) {
        t = t.replace(/\./g, "");
        // Keep last comma as decimal separator.
        const m = t.match(/^(\d+),(\d{2,3})$/);
        if (!m) return null;
        return m[1] + "." + m[2];
      }

      // Comma decimal
      if (t.includes(",")) {
        // Remove thousands dots just in case (rare in this branch)
        t = t.replace(/\./g, "");
        const m = t.match(/^(\d+),(\d{2,3})$/);
        if (!m) return null;
        return m[1] + "." + m[2];
      }

      // Dot decimal
      const m = t.match(/^(\d+)\.(\d{2,3})$/);
      if (m) return m[1] + "." + m[2];

      // Integer is not money here
      return null;
    }

    function isQtyToken(token) {
      // Quantity can be integer or 1-3 decimals (including 2 decimals).
      if (!token) return false;
      const t = token.replace(/\s+/g, "");
      if (/^\d+$/.test(t)) return true;
      if (/^\d+[.,]\d{1,3}$/.test(t)) return true;
      return false;
    }

    function isLikelyUnitToken(token) {
      // Unit: short non-numeric token, mostly letters/symbols, in the Unit column.
      if (!token) return false;
      const t = stripOuterPunct(token);
      if (!t) return false;
      if (/\d/.test(t)) {
        // Allow units like m2, m3, m², m³, kg, etc.
        if (/^(m2|m3|m²|m³|cm|mm|m|kg|t|h|l)$/i.test(t)) return true;
        return false;
      }
      if (/^(m2|m3|m²|m³|cm|mm|m|kg|t|h|l)$/i.test(t)) return true;
      // Generic short unit token: letters (unicode) or micro sign and superscripts
      try {
        if (/^[\p{L}µ²³\/]{1,10}$/u.test(t)) return true;
      } catch (_) {
        // Fallback without unicode properties
        if (/^[A-Za-zµ²³\/]{1,10}$/.test(t)) return true;
      }
      return false;
    }

    function removeTokenOnceByWhitespaceBoundary(text, token) {
      if (!text || !token) return text;
      const re = new RegExp("(^|\\s)" + escapeRegex(token) + "(?=\\s|$)");
      return text.replace(re, "$1").replace(/\s+/g, " ").trim();
    }

    function dotRatio(text) {
      if (!text) return 0;
      const dots = (text.match(/\./g) || []).length;
      return dots / Math.max(1, text.length);
    }

    function isLeaderLine(text) {
      // Mostly dots (leaders) with minimal payload
      const t = normalizeSpaces(text);
      if (!t) return true;
      if (dotRatio(t) > 0.25 && t.length > 10) return true;
      return false;
    }

    // =========================
    // Line building
    // =========================
    function median(arr) {
      if (!arr.length) return 0;
      const s = arr.slice().sort((a,b)=>a-b);
      const m = Math.floor(s.length/2);
      return s.length % 2 ? s[m] : (s[m-1]+s[m])/2;
    }

    function groupItemsIntoLines(items, pageHeight) {
      const enriched = [];
      const heights = [];

      for (const it of items) {
        const str = (it.str || "");
        if (!str.trim()) continue;
        const x = it.transform[4];
        const y = it.transform[5];
        const w = it.width || 0;
        // Approx font height from transform[3] if available.
        const h = Math.abs(it.transform[3] || it.height || 0);
        if (h > 1 && h < 60) heights.push(h);
        enriched.push({ str, x, y, w, xMid: x + w*0.5, h });
      }

      enriched.sort((a,b)=> b.y - a.y || a.x - b.x);

      const medH = median(heights) || 10;
      const yTol = Math.max(2.5, Math.min(10, medH * 0.35));

      const lines = [];
      for (const e of enriched) {
        const last = lines[lines.length-1];
        if (!last || Math.abs(last.y - e.y) > yTol) {
          lines.push({ y: e.y, yNorm: pageHeight ? (e.y / pageHeight) : 0, items: [e] });
        } else {
          last.items.push(e);
        }
      }
      for (const ln of lines) ln.items.sort((a,b)=>a.x-b.x);
      return { lines, yTol, medH };
    }

    // =========================
    // Column assignment
    // =========================
    function boundariesPx(boundariesNorm, pageWidth) {
      return boundariesNorm.map(v => v * pageWidth);
    }

    function regionIndexForX(xMid, bPx) {
      // 6 regions: 0=pos,1=qty,2=unit,3=ep,4=gp,5=desc
      if (xMid < bPx[0]) return 0;
      if (xMid < bPx[1]) return 1;
      if (xMid < bPx[2]) return 2;
      if (xMid < bPx[3]) return 3;
      if (xMid < bPx[4]) return 4;
      return 5;
    }

    function splitToTokensPreserve(str) {
      return normalizeSpaces(str).split(" ").filter(Boolean);
    }

    function lineRegions(line, bPx) {
      const regions = [[],[],[],[],[],[]];
      for (const it of line.items) {
        const r = regionIndexForX(it.xMid, bPx);
        regions[r].push(it);
      }
      return regions;
    }

    function findPosCandidate(line, bPx, pageWidth) {
      // Search in first two regions, token-based (robust against boundary drift).
      const regions = lineRegions(line, bPx);
      const candidates = [];

      function pushFromItems(items) {
        for (const it of items) {
          const toks = splitToTokensPreserve(it.str);
          for (const raw of toks) {
            const tok = stripOuterPunct(raw);
            if (!tok) continue;
            if (!isPosToken(tok)) continue;
            // Score: prefer dotted codes ending with 4 digits, and leftmost items.
            let score = 0;
            if (isDottedNumericCode(tok) && endsWithFourDigits(tok)) score += 100;
            else if (isDottedNumericCode(tok)) score += 70;
            else if (/^\d{1,6}$/.test(tok)) score += 50;
            else score += 40;
            // Left bias
            score += Math.max(0, 30 - (it.x / Math.max(1, pageWidth)) * 30);
            candidates.push({ tok, score, x: it.x });
          }
        }
      }

      pushFromItems(regions[0]);
      pushFromItems(regions[1]);

      if (candidates.length === 0) {
        // Fallback: scan first few leftmost items on the line (layout-agnostic).
        const leftMost = line.items.slice(0, Math.min(6, line.items.length));
        pushFromItems(leftMost);
      }

      if (candidates.length === 0) return null;

      candidates.sort((a,b)=> b.score - a.score || a.x - b.x);
      return candidates[0].tok;
    }

    function findQtyToken(regions) {
      const items = regions[1] || [];
      for (const it of items) {
        for (const raw of splitToTokensPreserve(it.str)) {
          const tok = stripOuterPunct(raw);
          if (!tok) continue;
          if (isQtyToken(tok)) return tok;
        }
      }
      return "";
    }

    function findUnitToken(regions) {
      const items = regions[2] || [];
      for (const it of items) {
        for (const raw of splitToTokensPreserve(it.str)) {
          const tok = stripOuterPunct(raw);
          if (!tok) continue;
          if (isLikelyUnitToken(tok)) return tok;
        }
      }
      return "";
    }

    function findMoneyInRegion(items) {
      for (const it of (items || [])) {
        for (const raw of splitToTokensPreserve(it.str)) {
          const tok = stripOuterPunct(raw);
          const m = parseMoneyToken(tok);
          if (m) return { raw: tok, norm: m };
        }
      }
      return null;
    }

    function findMoneyByLabel(lineText, label) {
      // Label-driven search (EP/GP). No language dependency.
      const t = normalizeSpaces(lineText);
      if (!t) return null;
      // If label occurs, look for the first money-like token after it.
      const idx = t.indexOf(label);
      if (idx < 0) return null;
      const after = t.slice(idx + label.length);
      const parts = after.split(" ").filter(Boolean);
      for (const p of parts) {
        const m = parseMoneyToken(stripOuterPunct(p));
        if (m) return m;
      }
      return null;
    }

    // =========================
    // Noise filtering (language-agnostic, repetition-based)
    // =========================
    async function buildNoiseSet(doc) {
      const occurrences = new Map(); // key -> count
      const topThresh = 0.82;
      const bottomThresh = 0.10;

      for (let p=1; p<=doc.numPages; p++) {
        const page = await doc.getPage(p);
        const viewport = page.getViewport({ scale: 1.0 });
        const textContent = await page.getTextContent();
        const { lines } = groupItemsIntoLines(textContent.items || [], viewport.height);

        for (const ln of lines) {
          const yNorm = ln.y / Math.max(1, viewport.height);
          if (!(yNorm >= topThresh || yNorm <= bottomThresh)) continue;
          const raw = ln.items.map(x => x.str).join(" ");
          const key = normalizeSpaces(raw).toLowerCase();
          if (!key) continue;
          // Skip extremely long blocks
          if (key.length > 140) continue;
          occurrences.set(key, (occurrences.get(key) || 0) + 1);
        }
      }

      const noise = new Set();
      for (const [k, c] of occurrences.entries()) {
        if (c >= 2) noise.add(k);
      }
      return noise;
    }

    // =========================
    // Extraction core (with fail-safe fallback)
    // =========================
    function getPrimaryExtractionMode() {
      // Priority: session guides (when checkbox is on) > preset > auto
      if ($("chkCalib").checked && sessionGuides && sessionGuides.boundariesNorm) return { type: "session", boundariesNorm: sessionGuides.boundariesNorm };
      if (preset && preset.boundariesNorm) return { type: "preset", boundariesNorm: preset.boundariesNorm };
      return { type: "auto", boundariesNorm: null };
    }

    function makeRow(seite, pos, qty, unit, ep, gp, desc) {
      return {
        "Seite": seite ?? "",
        "Pos": pos ?? "",
        "Menge": qty ?? "",
        "Menge Einheit": unit ?? "",
        "EP": ep ?? "",
        "GP": gp ?? "",
        "Beschreibung": desc ?? ""
      };
    }

    function flushOpenPosition(openPos, rowsOut) {
      if (!openPos) return null;
      const desc = openPos.descLines.filter(Boolean).join("\n").trim();
      rowsOut.push(makeRow(openPos.pageStart ?? "", openPos.pos ?? "", openPos.qty ?? "", openPos.unit ?? "", openPos.ep ?? "", openPos.gp ?? "", desc));
      return null;
    }

    function isMeaningfulTextForDesc(text) {
      const t = normalizeSpaces(text);
      if (!t) return false;
      // Ignore heavy leader-only lines
      if (isLeaderLine(t) && !/[A-Za-z]/.test(t)) return false;
      // Ignore very short pure punctuation
      if (/^[\.\-_:;]+$/.test(t)) return false;
      return true;
    }

    function lineToText(line) {
      return normalizeSpaces(line.items.map(x => x.str).join(" "));
    }

    function extractFromDocWithMode(mode, noiseSet) {
      // mode: { type: "session"|"preset"|"auto"|"forceAuto", boundariesNorm: number[]|null }
      const rows = [];
      let openPos = null;

      // This function is called from an async loop, but kept sync for clarity.
      // It relies on the caller to supply per-page lines and page models.
      function processPage(p, viewport, textContent, pageModel) {
        const activeBoundariesNorm =
          (mode.type === "session" || mode.type === "preset") ? mode.boundariesNorm :
          pageModel.boundariesNorm;

        const bPx = boundariesPx(activeBoundariesNorm, viewport.width);

        const grouped = groupItemsIntoLines(textContent.items || [], viewport.height);
        const lines = grouped.lines;

        for (const ln of lines) {
          const raw = ln.items.map(x => x.str).join(" ");
          const key = normalizeSpaces(raw).toLowerCase();
          if (noiseSet && noiseSet.has(key)) continue;

          const fullText = normalizeSpaces(raw);
          if (!fullText) continue;

          // Regions for field extraction
          const regions = lineRegions(ln, bPx);

          // Token-based pos detection (robust)
          const posTok = findPosCandidate(ln, bPx, viewport.width);

          // Detect qty/unit/price signals (used for override decisions)
          const qtyTok = findQtyToken(regions);
          const unitTok = findUnitToken(regions);
          const epInCol = findMoneyInRegion(regions[3]);
          const gpInCol = findMoneyInRegion(regions[4]);

          const epByLabel = findMoneyByLabel(fullText, "EP");
          const gpByLabel = findMoneyByLabel(fullText, "GP");

          const hasQtyOrPriceSignal = Boolean(qtyTok || unitTok || epInCol || gpInCol || epByLabel || gpByLabel);

          if (posTok) {
            const titleLike = isTitleCode(posTok);
            const posLikeStrong = isDottedNumericCode(posTok) && endsWithFourDigits(posTok);
            const posLike = !titleLike || (titleLike && hasQtyOrPriceSignal); // override: short dotted + qty/price => position

            if (posLikeStrong || posLike) {
              // Start a new position OR a title row depending on titleLike and override.
              if (titleLike && !hasQtyOrPriceSignal) {
                // Title/Section row (only Pos and Beschreibung filled)
                openPos = flushOpenPosition(openPos, rows);
                let descLine = fullText;
                descLine = removeTokenOnceByWhitespaceBoundary(descLine, posTok);
                rows.push(makeRow("", posTok, "", "", "", "", descLine));
                continue;
              }

              // New position row
              openPos = flushOpenPosition(openPos, rows);
              openPos = { pageStart: p, pos: posTok, qty: "", unit: "", ep: "", gp: "", descLines: [] };

              // Set fields from this line if present
              if (qtyTok) openPos.qty = qtyTok.replace(/\s+/g,"").trim();
              if (unitTok) openPos.unit = unitTok.trim();

              const epNorm = epInCol ? epInCol.norm : (epByLabel || "");
              const gpNorm = gpInCol ? gpInCol.norm : (gpByLabel || "");
              if (epNorm) openPos.ep = epNorm;
              if (gpNorm) openPos.gp = gpNorm;

              // Description line: remove field tokens from the full line text
              let descLine = fullText;
              descLine = removeTokenOnceByWhitespaceBoundary(descLine, posTok);
              if (qtyTok) descLine = removeTokenOnceByWhitespaceBoundary(descLine, qtyTok);
              if (unitTok) descLine = removeTokenOnceByWhitespaceBoundary(descLine, unitTok);
              if (epInCol && epInCol.raw) descLine = removeTokenOnceByWhitespaceBoundary(descLine, epInCol.raw);
              if (gpInCol && gpInCol.raw) descLine = removeTokenOnceByWhitespaceBoundary(descLine, gpInCol.raw);

              // Do not drop embedded patterns like "20cm" (removal uses whitespace boundaries)
              if (isMeaningfulTextForDesc(descLine)) openPos.descLines.push(descLine);
              continue;
            }
          }

          // Continuation lines
          if (openPos) {
            // Fill missing qty/unit
            if (!openPos.qty) {
              if (qtyTok) openPos.qty = qtyTok.replace(/\s+/g,"").trim();
            }
            if (!openPos.unit) {
              if (unitTok) openPos.unit = unitTok.trim();
            }

            // Fill EP/GP
            if (!openPos.ep) {
              const epNorm = epInCol ? epInCol.norm : (epByLabel || "");
              if (epNorm) openPos.ep = epNorm;
            }
            if (!openPos.gp) {
              const gpNorm = gpInCol ? gpInCol.norm : (gpByLabel || "");
              if (gpNorm) openPos.gp = gpNorm;
            }

            // Append description unless it's a pure leader line
            // Keep single-word lines (requirement)
            if (isMeaningfulTextForDesc(fullText)) {
              // If line is mostly leaders and was only used to capture price, skip adding to description.
              const usedForMoneyOnly = (isLeaderLine(fullText) && (epByLabel || gpByLabel || epInCol || gpInCol));
              if (!usedForMoneyOnly) openPos.descLines.push(fullText);
            }
          }
        }
      }

      return { rows, processPage, flush: () => { openPos = flushOpenPosition(openPos, rows); return rows; } };
    }

    async function extractAllPagesWithFailSafe() {
      if (!pdfDoc) return [];

      const noiseSet = await buildNoiseSet(pdfDoc);
      log("Noise filter built. Entries: " + noiseSet.size);

      const primary = getPrimaryExtractionMode();
      const runOnce = async (mode, label) => {
        log("Extraction run: " + label);
        const ctx = extractFromDocWithMode(mode, noiseSet);

        for (let p=1; p<=pdfDoc.numPages; p++) {
          const page = await pdfDoc.getPage(p);
          const viewport = page.getViewport({ scale: 1.0 });
          const textContent = await page.getTextContent();
          const pageModel = buildAutoColumnModel(textContent, viewport.width);
          ctx.processPage(p, viewport, textContent, pageModel);
        }
        return ctx.flush();
      };

      // 1) Primary run (session guides / preset / auto)
      let rows = await runOnce(
        primary.type === "auto" ? { type:"auto", boundariesNorm:null } : primary,
        primary.type === "auto" ? "auto clustering" : primary.type
      );

      // 2) Fail-safe: if rows == 0, retry with forced auto clustering (ignore preset/guides)
      if (rows.length === 0) {
        log("Zero rows detected. Retrying with auto clustering (ignoring preset/guides)...");
        rows = await runOnce({ type:"auto", boundariesNorm:null }, "auto clustering (fail-safe)");
      }

      return rows;
    }

    // =========================
    // Export
    // =========================
    function exportXlsx() {
      if (!extractedRows || extractedRows.length === 0) return;
      const cols = ["Seite","Pos","Menge","Menge Einheit","EP","GP","Beschreibung"];
      const wsData = [cols];
      for (const r of extractedRows) wsData.push(cols.map(c => r[c] ?? ""));
      const ws = XLSX.utils.aoa_to_sheet(wsData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "LV");
      XLSX.writeFile(wb, "LVtoExcel_" + VERSION_TAG + ".xlsx");
      log("XLSX exported.");
    }

    // =========================
    // Wire up UI
    // =========================
    (function init() {
      $("kpiVersion").textContent = "VERSION_TAG=" + VERSION_TAG;
      $("kpiMode").textContent = "Mode: -";
      $("kpiCols").textContent = "Boundaries: -";
      log("Ready. VERSION_TAG=" + VERSION_TAG);

      $("fileInput").addEventListener("change", () => {
        const f = $("fileInput").files?.[0] || null;
        $("btnLoad").disabled = !f;
        $("btnExtract").disabled = true;
        $("btnExport").disabled = true;

        pdfDoc = null;
        currentPage = 1;
        extractedRows = [];
        preset = null;
        sessionGuides = null;
        clearTable();

        if (f) {
          fileMetaKey = makeFileKey(f);
          preset = loadPresetForFile();
          updatePresetUI();
          setKpi();
          log("File selected: " + f.name);
        }
      });

      $("btnLoad").addEventListener("click", async () => {
        const f = $("fileInput").files?.[0];
        if (!f) return;
        try {
          const buf = await f.arrayBuffer();
          const loadingTask = pdfjsLib.getDocument({ data: buf });
          pdfDoc = await loadingTask.promise;
          currentPage = 1;

          log("PDF loaded. Pages: " + pdfDoc.numPages);

          $("btnPrev").disabled = false;
          $("btnNext").disabled = false;
          $("btnExtract").disabled = false;

          // Render preview immediately
          await renderCurrentPage();

          updatePresetUI();
          setKpi();
        } catch (e) {
          log("ERROR loading PDF: " + (e?.message || String(e)));
        }
      });

      $("btnPrev").addEventListener("click", async () => {
        if (!pdfDoc) return;
        currentPage = Math.max(1, currentPage - 1);
        await renderCurrentPage();
      });

      $("btnNext").addEventListener("click", async () => {
        if (!pdfDoc) return;
        currentPage = Math.min(pdfDoc.numPages, currentPage + 1);
        await renderCurrentPage();
      });

      $("chkCalib").addEventListener("change", () => {
        const enabled = $("chkCalib").checked;
        setGuidesEnabled(enabled);

        if (enabled) {
          // Initialize session guides from preset or auto/default
          const b = (preset && preset.boundariesNorm) ? preset.boundariesNorm
                  : (autoModel && autoModel.boundariesNorm) ? autoModel.boundariesNorm
                  : DEFAULT_BOUNDARIES;
          sessionGuides = { boundariesNorm: b.slice() };
          applyGuides(sessionGuides.boundariesNorm);
        } else {
          sessionGuides = null;
          applyGuides(getActiveBoundariesNormForPreview());
        }

        updatePresetUI();
        setKpi();
      });

      $("btnSavePreset").addEventListener("click", () => {
        if (!$("chkCalib").checked) return;
        const b = getBoundariesFromGuides();
        // Save preset; keep session guides active as well.
        savePresetForFile(b);
        sessionGuides = { boundariesNorm: b.slice() };
        applyGuides(b);
        setKpi();
      });

      $("btnClearPreset").addEventListener("click", () => {
        clearPresetForFile();
        // Do not touch session guides unless calibration is off
        if (!$("chkCalib").checked) sessionGuides = null;
        const b = getActiveBoundariesNormForPreview();
        applyGuides(b);
        setKpi();
      });

      $("btnExtract").addEventListener("click", async () => {
        if (!pdfDoc) return;
        $("btnExport").disabled = true;
        extractedRows = [];
        clearTable();

        // Refresh preset from storage (in case file key changed)
        preset = loadPresetForFile();

        setKpi();
        log("Extract started...");

        try {
          extractedRows = await extractAllPagesWithFailSafe();
          log("Extract done. Rows: " + extractedRows.length);
          renderTable(extractedRows);
          $("btnExport").disabled = extractedRows.length === 0;
        } catch (e) {
          log("ERROR extracting: " + (e?.message || String(e)));
        }
      });

      $("btnExport").addEventListener("click", exportXlsx);

      // Initial guides (hidden until enabled)
      applyGuides(DEFAULT_BOUNDARIES);
      setGuidesEnabled(false);
      updatePresetUI();
      setKpi();
    })();
  </script>
</body>
</html>
