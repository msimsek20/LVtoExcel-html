<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LVtoExcel (browser-only)</title>
  <style>
    :root { --border:#d0d7de; --bg:#ffffff; --muted:#57606a; --shadow:0 1px 2px rgba(0,0,0,.06); }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 18px; color:#111; background:var(--bg); }
    h1 { font-size: 20px; margin: 0 0 8px 0; }
    .sub { color: var(--muted); font-size: 13px; margin-bottom: 14px; }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items:center; }
    .card { border:1px solid var(--border); border-radius: 10px; padding: 12px; box-shadow: var(--shadow); background:#fff; }
    .btn { border:1px solid var(--border); background:#f6f8fa; padding: 8px 12px; border-radius: 8px; cursor:pointer; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    input[type="file"] { padding: 6px; }
    .tiny { font-size: 12px; color: var(--muted); }
    textarea { width:100%; height: 170px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; padding: 10px; border-radius: 10px; border:1px solid var(--border); }
    table { width:100%; border-collapse: collapse; font-size: 12px; }
    th, td { border:1px solid var(--border); padding: 6px 8px; vertical-align: top; }
    th { background:#f6f8fa; position: sticky; top: 0; z-index: 1; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 1100px) { .grid { grid-template-columns: 520px 1fr; } }
    .canvasWrap { position: relative; border:1px solid var(--border); border-radius: 10px; overflow: hidden; background:#fff; }
    canvas { width:100%; height:auto; display:block; }
    .overlay { position:absolute; inset:0; pointer-events:none; }
    .guideV { position:absolute; top:0; bottom:0; width:2px; background: rgba(255,0,0,0.75); pointer-events:auto; cursor: ew-resize; }
    .guideH { position:absolute; left:0; right:0; height:2px; background: rgba(0,128,255,0.75); pointer-events:auto; cursor: ns-resize; }
    .guideLabel { position:absolute; top:6px; transform: translateX(-50%); background: rgba(255,255,255,0.92); border:1px solid var(--border); border-radius: 8px; padding: 2px 6px; font-size: 11px; color:#111; pointer-events:none; }
    .guideLabelH { position:absolute; left:6px; transform: translateY(-50%); background: rgba(255,255,255,0.92); border:1px solid var(--border); border-radius: 8px; padding: 2px 6px; font-size: 11px; color:#111; pointer-events:none; }
    .zone { position:absolute; left:0; right:0; background: rgba(0,128,255,0.08); pointer-events:none; }
    .kpi { display:flex; gap:10px; flex-wrap:wrap; }
    .pill { border:1px solid var(--border); border-radius:999px; padding:4px 8px; font-size:12px; background:#fff; }
    .warn { color:#b54708; }
  </style>
</head>
<body>
  <h1>LVtoExcel (browser-only)</h1>
  <div class="sub">Loads local <b>pdf.min.js</b>, <b>pdf.worker.min.js</b>, <b>xlsx.full.min.js</b> from the same folder.</div>

  <div class="card">
    <div class="row" style="margin-bottom:8px;">
      <input id="fileInput" type="file" accept="application/pdf" />
      <button id="btnLoad" class="btn" disabled>Load PDF</button>
      <button id="btnExtract" class="btn" disabled>Extract</button>
      <button id="btnExport" class="btn" disabled>Export XLSX</button>
      <div class="tiny">Output columns: Seite | Pos | Menge | Menge Einheit | EP | GP | Beschreibung</div>
    </div>

    <div class="row" style="gap:18px; margin-top:6px;">
      <div class="row" style="gap:8px;">
        <button id="btnPrev" class="btn" disabled>◀ Page</button>
        <button id="btnNext" class="btn" disabled>Page ▶</button>
        <span class="tiny" id="pageInfo">No PDF loaded</span>
      </div>

      <div class="row" style="gap:10px;">
        <label class="tiny"><input type="checkbox" id="chkCalib" /> Enable calibration guides</label>
        <button id="btnSavePreset" class="btn" disabled>Save preset</button>
        <button id="btnClearPreset" class="btn" disabled>Clear preset</button>
        <span class="tiny" id="presetInfo"></span>
      </div>
    </div>

    <div class="kpi" style="margin-top:8px;">
      <span class="pill" id="kpiVersion"></span>
      <span class="pill" id="kpiMode"></span>
      <span class="pill" id="kpiCols"></span>
      <span class="pill" id="kpiCuts"></span>
    </div>
  </div>

  <div class="grid" style="margin-top:12px;">
    <div class="card">
      <div style="display:flex; justify-content: space-between; align-items:center; margin-bottom:8px;">
        <div><b>PDF preview</b> <span class="tiny">(always available after Load PDF)</span></div>
        <div class="tiny warn" id="previewWarn"></div>
      </div>
      <div class="canvasWrap" id="canvasWrap">
        <canvas id="pdfCanvas"></canvas>
        <div class="overlay" id="overlay"></div>
      </div>
      <div class="tiny" style="margin-top:8px;">
        Red lines split columns (Pos | Qty | Unit | EP | GP | Desc). Blue lines set Header/Footer ignore zones.
      </div>
    </div>

    <div class="card">
      <b>Log</b>
      <textarea id="log" readonly></textarea>
      <div style="height:10px;"></div>
      <b>Preview (first 50 rows)</b>
      <div style="max-height: 360px; overflow:auto; border:1px solid var(--border); border-radius:10px; margin-top:8px;">
        <table id="tbl">
          <thead>
            <tr>
              <th>Seite</th>
              <th>Pos</th>
              <th>Menge</th>
              <th>Menge Einheit</th>
              <th>EP</th>
              <th>GP</th>
              <th>Beschreibung</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Local dependencies (must be in same folder) -->
  <script src="./pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = "./pdf.worker.min.js";
  </script>
  <script src="./xlsx.full.min.js"></script>

  <script>
    // =========================
    // Versioning
    // =========================
    const VERSION_TAG = "20251218_1157";

    // =========================
    // State
    // =========================
    let pdfDoc = null;
    let currentPage = 1;
    let fileMetaKey = null;
    let extractedRows = [];
    let preset = null;            // { boundariesNorm:number[], headerCut:number, footerCut:number }
    let sessionGuides = null;     // same shape as preset (not persisted)
    let autoModel = null;         // { boundariesNorm, centers, assignmentMode }

    // Columns: 6 regions split by 5 vertical boundaries [0..1]
    const DEFAULT_BOUNDARIES = [0.22, 0.34, 0.44, 0.60, 0.72];

    // Header/Footer cuts (normalized y in [0..1], y increases upward in PDF space)
    // Ignore: yNorm >= headerCut (top zone) and yNorm <= footerCut (bottom zone)
    const DEFAULT_HEADER_CUT = 0.88;
    const DEFAULT_FOOTER_CUT = 0.10;

    // =========================
    // UI Helpers
    // =========================
    const $ = (id) => document.getElementById(id);
    function log(msg) {
      const ta = $("log");
      ta.value += msg + "\n";
      ta.scrollTop = ta.scrollHeight;
    }
    function clearTable() {
      $("tbl").querySelector("tbody").innerHTML = "";
    }
    function renderTable(rows) {
      const tbody = $("tbl").querySelector("tbody");
      tbody.innerHTML = "";
      const show = rows.slice(0, 50);
      for (const r of show) {
        const tr = document.createElement("tr");
        const cols = ["Seite","Pos","Menge","Menge Einheit","EP","GP","Beschreibung"];
        for (const c of cols) {
          const td = document.createElement("td");
          td.textContent = (r[c] ?? "");
          if (c === "Beschreibung") td.style.whiteSpace = "pre-wrap";
          tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
    }

    function setKpi() {
      $("kpiVersion").textContent = "VERSION_TAG=" + VERSION_TAG;

      const mode =
        (sessionGuides && sessionGuides.boundariesNorm) ? "Mode: Session guides" :
        (preset && preset.boundariesNorm) ? "Mode: Preset" :
        "Mode: Auto clustering";
      $("kpiMode").textContent = mode;

      const b = getActiveBoundariesNorm();
      $("kpiCols").textContent = "Boundaries: " + b.map(v => v.toFixed(2)).join(", ");

      const cuts = getActiveCuts();
      $("kpiCuts").textContent = `Cuts: header>=${cuts.headerCut.toFixed(2)} footer<=${cuts.footerCut.toFixed(2)}`;
    }

    // =========================
    // Preset storage
    // =========================
    function makeFileKey(file) {
      return "LVtoExcel:preset:" + [file.name, file.size, file.lastModified].join("|");
    }

    function normalizePreset(obj) {
      if (!obj || typeof obj !== "object") return null;
      const boundariesNorm = Array.isArray(obj.boundariesNorm) && obj.boundariesNorm.length === 5 ? obj.boundariesNorm : null;
      const headerCut = (typeof obj.headerCut === "number") ? obj.headerCut : DEFAULT_HEADER_CUT;
      const footerCut = (typeof obj.footerCut === "number") ? obj.footerCut : DEFAULT_FOOTER_CUT;
      if (!boundariesNorm) return null;
      return { boundariesNorm, headerCut, footerCut };
    }

    function loadPresetForFile() {
      if (!fileMetaKey) return null;
      try {
        const raw = localStorage.getItem(fileMetaKey);
        if (!raw) return null;
        return normalizePreset(JSON.parse(raw));
      } catch (_) {}
      return null;
    }

    function savePresetForFile(p) {
      if (!fileMetaKey) return;
      localStorage.setItem(fileMetaKey, JSON.stringify(p));
      preset = p;
      updatePresetUI();
      setKpi();
      log("Preset saved.");
    }

    function clearPresetForFile() {
      if (!fileMetaKey) return;
      localStorage.removeItem(fileMetaKey);
      preset = null;
      updatePresetUI();
      setKpi();
      log("Preset cleared.");
    }

    function updatePresetUI() {
      if (!fileMetaKey) {
        $("presetInfo").textContent = "";
        $("btnSavePreset").disabled = true;
        $("btnClearPreset").disabled = true;
        return;
      }
      preset = loadPresetForFile();
      if (preset) {
        $("presetInfo").textContent = "Preset loaded for this PDF.";
        $("btnClearPreset").disabled = false;
      } else {
        $("presetInfo").textContent = "No preset for this PDF.";
        $("btnClearPreset").disabled = true;
      }
      $("btnSavePreset").disabled = !$("chkCalib").checked;
    }

    // =========================
    // Guides (vertical columns + horizontal header/footer)
    // =========================
    const GUIDE_NAMES_V = ["Pos", "Qty", "Unit", "EP", "GP"];
    let guidesV = []; // {el,labelEl,idx,normX}
    let guideHeader = null; // {el,labelEl,normY}
    let guideFooter = null; // {el,labelEl,normY}
    let zoneTop = null;
    let zoneBottom = null;

    function canvasRect() { return $("pdfCanvas").getBoundingClientRect(); }

    function getActiveBoundariesNorm() {
      if ($("chkCalib").checked && sessionGuides && sessionGuides.boundariesNorm) return sessionGuides.boundariesNorm;
      if (preset && preset.boundariesNorm) return preset.boundariesNorm;
      if (autoModel && autoModel.boundariesNorm) return autoModel.boundariesNorm;
      return DEFAULT_BOUNDARIES;
    }

    function getActiveCuts() {
      const headerCut =
        ($("chkCalib").checked && sessionGuides && typeof sessionGuides.headerCut === "number") ? sessionGuides.headerCut :
        (preset && typeof preset.headerCut === "number") ? preset.headerCut :
        DEFAULT_HEADER_CUT;
      const footerCut =
        ($("chkCalib").checked && sessionGuides && typeof sessionGuides.footerCut === "number") ? sessionGuides.footerCut :
        (preset && typeof preset.footerCut === "number") ? preset.footerCut :
        DEFAULT_FOOTER_CUT;
      return { headerCut, footerCut };
    }

    function applyGuides() {
      const overlay = $("overlay");
      overlay.innerHTML = "";
      guidesV = [];
      guideHeader = null;
      guideFooter = null;

      const rect = canvasRect();
      const w = rect.width || 1;
      const h = rect.height || 1;

      const boundariesNorm = getActiveBoundariesNorm();
      boundariesNorm.forEach((nx, idx) => {
        const x = nx * w;

        const line = document.createElement("div");
        line.className = "guideV";
        line.style.left = `${x}px`;

        const label = document.createElement("div");
        label.className = "guideLabel";
        label.style.left = `${x}px`;
        label.textContent = GUIDE_NAMES_V[idx];

        overlay.appendChild(line);
        overlay.appendChild(label);

        guidesV.push({ el: line, labelEl: label, idx, normX: nx });
      });

      const cuts = getActiveCuts();

      // Header line
      const yHeader = (1 - cuts.headerCut) * h; // convert yNorm to CSS top (top=0)
      const headerLine = document.createElement("div");
      headerLine.className = "guideH";
      headerLine.style.top = `${yHeader}px`;
      const headerLabel = document.createElement("div");
      headerLabel.className = "guideLabelH";
      headerLabel.style.top = `${yHeader}px`;
      headerLabel.textContent = "Header cut";

      // Footer line
      const yFooter = (1 - cuts.footerCut) * h;
      const footerLine = document.createElement("div");
      footerLine.className = "guideH";
      footerLine.style.top = `${yFooter}px`;
      const footerLabel = document.createElement("div");
      footerLabel.className = "guideLabelH";
      footerLabel.style.top = `${yFooter}px`;
      footerLabel.textContent = "Footer cut";

      // Shaded zones (ignored areas)
      zoneTop = document.createElement("div");
      zoneTop.className = "zone";
      zoneTop.style.top = "0px";
      zoneTop.style.height = `${Math.max(0, yHeader)}px`;

      zoneBottom = document.createElement("div");
      zoneBottom.className = "zone";
      zoneBottom.style.top = `${Math.min(h, yFooter)}px`;
      zoneBottom.style.height = `${Math.max(0, h - yFooter)}px`;

      overlay.appendChild(zoneTop);
      overlay.appendChild(zoneBottom);
      overlay.appendChild(headerLine);
      overlay.appendChild(headerLabel);
      overlay.appendChild(footerLine);
      overlay.appendChild(footerLabel);

      guideHeader = { el: headerLine, labelEl: headerLabel, normY: cuts.headerCut };
      guideFooter = { el: footerLine, labelEl: footerLabel, normY: cuts.footerCut };

      setGuidesEnabled($("chkCalib").checked);
      attachGuideDrag();
    }

    function setGuidesEnabled(enabled) {
      for (const g of guidesV) {
        g.el.style.display = enabled ? "block" : "none";
        g.labelEl.style.display = enabled ? "block" : "none";
      }
      if (guideHeader) {
        guideHeader.el.style.display = enabled ? "block" : "none";
        guideHeader.labelEl.style.display = enabled ? "block" : "none";
      }
      if (guideFooter) {
        guideFooter.el.style.display = enabled ? "block" : "none";
        guideFooter.labelEl.style.display = enabled ? "block" : "none";
      }
      if (zoneTop) zoneTop.style.display = enabled ? "block" : "none";
      if (zoneBottom) zoneBottom.style.display = enabled ? "block" : "none";
      $("btnSavePreset").disabled = !enabled;
    }

    function getBoundariesFromGuidesV() {
      const arr = guidesV.map(g => g.normX).slice();
      const clamped = arr.map(v => Math.max(0.05, Math.min(0.95, v)));
      clamped.sort((a,b)=>a-b);
      const minGap = 0.03;
      for (let i=1;i<clamped.length;i++) {
        if (clamped[i] - clamped[i-1] < minGap) clamped[i] = clamped[i-1] + minGap;
      }
      for (let i=0;i<clamped.length;i++) clamped[i] = Math.max(0.05, Math.min(0.95, clamped[i]));
      return clamped;
    }

    function clampCuts(headerCut, footerCut) {
      // Keep header above footer by margin
      let h = Math.max(0.30, Math.min(0.98, headerCut));
      let f = Math.max(0.02, Math.min(0.40, footerCut));
      const minGap = 0.10;
      if (h - f < minGap) {
        // push them apart conservatively
        const mid = (h + f) / 2;
        h = Math.min(0.98, mid + minGap/2);
        f = Math.max(0.02, mid - minGap/2);
      }
      return { headerCut: h, footerCut: f };
    }

    function attachGuideDrag() {
      // Vertical drag
      for (const g of guidesV) {
        g.el.onpointerdown = (ev) => {
          if (!$("chkCalib").checked) return;
          ev.preventDefault();
          g.el.setPointerCapture(ev.pointerId);

          const move = (e) => {
            const rect = canvasRect();
            const x = e.clientX - rect.left;
            const nx = x / Math.max(1, rect.width);
            g.normX = Math.max(0.02, Math.min(0.98, nx));
            const px = g.normX * rect.width;
            g.el.style.left = `${px}px`;
            g.labelEl.style.left = `${px}px`;
          };

          const up = () => {
            const b = getBoundariesFromGuidesV();
            const cuts = sessionGuides ? clampCuts(sessionGuides.headerCut ?? DEFAULT_HEADER_CUT, sessionGuides.footerCut ?? DEFAULT_FOOTER_CUT) : clampCuts(DEFAULT_HEADER_CUT, DEFAULT_FOOTER_CUT);
            sessionGuides = { boundariesNorm: b, headerCut: cuts.headerCut, footerCut: cuts.footerCut };
            applyGuides();
            setKpi();
          };

          g.el.onpointermove = move;
          g.el.onpointerup = up;
        };
      }

      // Horizontal drag helper
      function attachH(guideObj, kind) {
        if (!guideObj) return;
        guideObj.el.onpointerdown = (ev) => {
          if (!$("chkCalib").checked) return;
          ev.preventDefault();
          guideObj.el.setPointerCapture(ev.pointerId);

          const move = (e) => {
            const rect = canvasRect();
            const y = e.clientY - rect.top;   // 0..h (top-down)
            const nyDown = y / Math.max(1, rect.height);
            const yNorm = 1 - nyDown;         // convert to PDF yNorm (bottom=0, top=1)
            if (kind === "header") guideObj.normY = Math.max(0.30, Math.min(0.98, yNorm));
            if (kind === "footer") guideObj.normY = Math.max(0.02, Math.min(0.40, yNorm));

            // Visual update
            const px = (1 - guideObj.normY) * rect.height;
            guideObj.el.style.top = `${px}px`;
            guideObj.labelEl.style.top = `${px}px`;

            // zones
            if (zoneTop) zoneTop.style.height = `${Math.max(0, px)}px`;
            if (zoneBottom) {
              zoneBottom.style.top = `${Math.min(rect.height, kind === "footer" ? px : (1 - (sessionGuides?.footerCut ?? DEFAULT_FOOTER_CUT)) * rect.height)}px`;
              const footerPx = (1 - (kind === "footer" ? guideObj.normY : (sessionGuides?.footerCut ?? DEFAULT_FOOTER_CUT))) * rect.height;
              zoneBottom.style.top = `${Math.min(rect.height, footerPx)}px`;
              zoneBottom.style.height = `${Math.max(0, rect.height - footerPx)}px`;
            }
          };

          const up = () => {
            const b = getBoundariesFromGuidesV();
            const headerCut = (kind === "header") ? guideObj.normY : (sessionGuides?.headerCut ?? DEFAULT_HEADER_CUT);
            const footerCut = (kind === "footer") ? guideObj.normY : (sessionGuides?.footerCut ?? DEFAULT_FOOTER_CUT);
            const cuts = clampCuts(headerCut, footerCut);
            sessionGuides = { boundariesNorm: b, headerCut: cuts.headerCut, footerCut: cuts.footerCut };
            applyGuides();
            setKpi();
          };

          guideObj.el.onpointermove = move;
          guideObj.el.onpointerup = up;
        };
      }

      attachH(guideHeader, "header");
      attachH(guideFooter, "footer");
    }

    // =========================
    // PDF Preview (stable)
    // =========================
    async function renderCurrentPage() {
      if (!pdfDoc) return;
      const page = await pdfDoc.getPage(currentPage);
      const viewport = page.getViewport({ scale: 1.6 });

      const canvas = $("pdfCanvas");
      const ctx = canvas.getContext("2d");
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);

      $("previewWarn").textContent = "";
      const renderTask = page.render({ canvasContext: ctx, viewport });
      await renderTask.promise;

      $("pageInfo").textContent = `Page ${currentPage} / ${pdfDoc.numPages}`;

      try {
        const textContent = await page.getTextContent();
        autoModel = buildAutoColumnModel(textContent, viewport.width);
        applyGuides();
      } catch (e) {
        $("previewWarn").textContent = "Preview model warning: " + (e?.message || String(e));
      }
      setKpi();
    }

    // =========================
    // Auto Column Model (x clustering)
    // =========================
    function clamp01(v){ return Math.max(0, Math.min(1, v)); }

    function snapToGap(x, centers, pageWidth) {
      if (!centers || centers.length < 2) return x;
      let best = x, bestDist = Infinity;
      for (let i=0;i<centers.length-1;i++) {
        const mid = (centers[i] + centers[i+1]) * 0.5;
        const dist = Math.abs(mid - x);
        if (dist < bestDist) { bestDist = dist; best = mid; }
      }
      return Math.max(pageWidth*0.05, Math.min(pageWidth*0.95, best));
    }

    function buildAutoColumnModel(textContent, pageWidthPx) {
      const xs = [];
      const items = textContent.items || [];
      for (const it of items) {
        const s = (it.str || "").trim();
        if (!s) continue;
        const x = it.transform[4];
        const w = it.width || 0;
        xs.push(x + w * 0.5);
      }
      if (xs.length < 30) {
        return { boundariesNorm: DEFAULT_BOUNDARIES.slice(), centers: [], assignmentMode: "fallback" };
      }
      xs.sort((a,b)=>a-b);

      // Greedy 1D clustering
      const clusters = [];
      const threshold = Math.max(10, pageWidthPx * 0.02);
      let cur = [xs[0]];
      for (let i=1;i<xs.length;i++) {
        if (xs[i] - xs[i-1] <= threshold) cur.push(xs[i]);
        else { clusters.push(cur); cur = [xs[i]]; }
      }
      clusters.push(cur);

      const centers = clusters.map(c => c.reduce((a,b)=>a+b,0)/c.length).sort((a,b)=>a-b);

      // Keep densest clusters
      let keep = clusters.map((c, idx)=>({ idx, count:c.length, center: centers[idx] }));
      keep.sort((a,b)=>b.count-a.count);
      keep = keep.slice(0, Math.min(10, keep.length));
      keep.sort((a,b)=>a.center-b.center);
      const keptCenters = keep.map(k=>k.center);

      // Quantile cuts snapped to gaps
      const q = (p) => xs[Math.floor((xs.length-1)*p)];
      const quant = [q(0.18), q(0.32), q(0.44), q(0.62), q(0.78)];
      const boundariesPx = quant.map(v => snapToGap(v, keptCenters, pageWidthPx));
      let boundariesNorm = boundariesPx.map(v => clamp01(v / Math.max(1, pageWidthPx)));

      boundariesNorm.sort((a,b)=>a-b);
      const minGap = 0.03;
      for (let i=1;i<boundariesNorm.length;i++) {
        if (boundariesNorm[i] - boundariesNorm[i-1] < minGap) boundariesNorm[i] = boundariesNorm[i-1] + minGap;
      }
      boundariesNorm = boundariesNorm.map(clamp01);

      return { boundariesNorm, centers: keptCenters, assignmentMode: "auto" };
    }

    // =========================
    // Parsing primitives
    // =========================
    function normalizeSpaces(s) { return (s || "").replace(/\s+/g, " ").trim(); }

    function stripOuterPunct(token) {
      let t = (token || "").trim();
      t = t.replace(/^[\(\[\{<]+/, "").replace(/[\)\]\}>]+$/, "");
      t = t.replace(/^[,:;]+/, "").replace(/[,:;]+$/, "");
      return t;
    }

    function escapeRegex(s) { return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }

    function removeTokenOnceByWhitespaceBoundary(text, token) {
      if (!text || !token) return text;
      const re = new RegExp("(^|\\s)" + escapeRegex(token) + "(?=\\s|$)");
      return text.replace(re, "$1").replace(/\s+/g, " ").trim();
    }

    function isDottedNumericCode(t) { return /^\d+(?:\.\d+)+$/.test(t.trim()); }
    function endsWithFourDigits(code) { return /\.\d{4}$/.test(code.trim()); }

    function isTitleCode(code) {
      if (!isDottedNumericCode(code)) return false;
      return !endsWithFourDigits(code);
    }

    function isPosToken(token) {
      const t = token.trim();
      if (!t) return false;
      if (isDottedNumericCode(t)) return true;
      if (/^\d{1,6}$/.test(t)) return true;
      if (/^[A-Z]\d{1,3}(?:[.-]\d{1,4})+$/i.test(t)) return true;
      return false;
    }

    function isIntegerPosCandidate(token) {
      const t = token.trim();
      return /^\d{1,6}$/.test(t);
    }

    function parseMoneyToken(token) {
      if (!token) return null;
      let t = token.replace(/\s+/g, "");
      t = t.replace(/[€$£]/g, "");
      if (!/\d/.test(t)) return null;

      if (t.includes(".") && t.includes(",")) {
        t = t.replace(/\./g, "");
        const m = t.match(/^(\d+),(\d{2,3})$/);
        if (!m) return null;
        return m[1] + "." + m[2];
      }
      if (t.includes(",")) {
        t = t.replace(/\./g, "");
        const m = t.match(/^(\d+),(\d{2,3})$/);
        if (!m) return null;
        return m[1] + "." + m[2];
      }
      const m = t.match(/^(\d+)\.(\d{2,3})$/);
      if (m) return m[1] + "." + m[2];
      return null;
    }

    function isQtyToken(token) {
      if (!token) return false;
      const t = token.replace(/\s+/g, "");
      if (/^\d+$/.test(t)) return true;
      if (/^\d+[.,]\d{1,3}$/.test(t)) return true;
      return false;
    }

    function isLikelyUnitToken(token) {
      if (!token) return false;
      const t = stripOuterPunct(token);
      if (!t) return false;
      if (/\d/.test(t)) {
        if (/^(m2|m3|m²|m³|cm|mm|m|kg|t|h|l)$/i.test(t)) return true;
        return false;
      }
      if (/^(m2|m3|m²|m³|cm|mm|m|kg|t|h|l)$/i.test(t)) return true;
      try {
        if (/^[\p{L}µ²³\/]{1,10}$/u.test(t)) return true;
      } catch (_) {
        if (/^[A-Za-zµ²³\/]{1,10}$/.test(t)) return true;
      }
      return false;
    }

    function dotRatio(text) {
      const t = text || "";
      const dots = (t.match(/\./g) || []).length;
      return dots / Math.max(1, t.length);
    }
    function isLeaderLine(text) {
      const t = normalizeSpaces(text);
      if (!t) return true;
      if (dotRatio(t) > 0.25 && t.length > 10) return true;
      return false;
    }

    function isMeaningfulTextForDesc(text) {
      const t = normalizeSpaces(text);
      if (!t) return false;
      if (isLeaderLine(t) && !/[A-Za-z]/.test(t)) return false;
      if (/^[\.\-_:;]+$/.test(t)) return false;
      return true;
    }

    // =========================
    // Line building (adaptive y tolerance)
    // =========================
    function median(arr) {
      if (!arr.length) return 0;
      const s = arr.slice().sort((a,b)=>a-b);
      const m = Math.floor(s.length/2);
      return s.length % 2 ? s[m] : (s[m-1]+s[m])/2;
    }

    function groupItemsIntoLines(items, pageHeight) {
      const enriched = [];
      const heights = [];

      for (const it of items) {
        const str = (it.str || "");
        if (!str.trim()) continue;
        const x = it.transform[4];
        const y = it.transform[5];
        const w = it.width || 0;
        const h = Math.abs(it.transform[3] || it.height || 0);
        if (h > 1 && h < 60) heights.push(h);
        enriched.push({ str, x, y, w, xMid: x + w*0.5, h });
      }

      enriched.sort((a,b)=> b.y - a.y || a.x - b.x);

      const medH = median(heights) || 10;
      const yTol = Math.max(2.5, Math.min(12, medH * 0.45));

      const lines = [];
      for (const e of enriched) {
        const last = lines[lines.length-1];
        if (!last || Math.abs(last.y - e.y) > yTol) {
          lines.push({ y: e.y, yNorm: e.y / Math.max(1, pageHeight), items: [e] });
        } else {
          last.items.push(e);
        }
      }
      for (const ln of lines) ln.items.sort((a,b)=>a.x-b.x);
      return { lines, yTol, medH };
    }

    // =========================
    // Column assignment
    // =========================
    function boundariesPx(boundariesNorm, pageWidth) { return boundariesNorm.map(v => v * pageWidth); }

    function regionIndexForX(xMid, bPx) {
      if (xMid < bPx[0]) return 0;
      if (xMid < bPx[1]) return 1;
      if (xMid < bPx[2]) return 2;
      if (xMid < bPx[3]) return 3;
      if (xMid < bPx[4]) return 4;
      return 5;
    }

    function splitToTokens(str) {
      return normalizeSpaces(str).split(" ").filter(Boolean);
    }

    function lineRegions(line, bPx) {
      const regions = [[],[],[],[],[],[]];
      for (const it of line.items) {
        const r = regionIndexForX(it.xMid, bPx);
        regions[r].push(it);
      }
      return regions;
    }

    function findMoneyInItems(items) {
      for (const it of (items || [])) {
        for (const raw of splitToTokens(it.str)) {
          const tok = stripOuterPunct(raw);
          const m = parseMoneyToken(tok);
          if (m) return { raw: tok, norm: m };
        }
      }
      return null;
    }

    function findQtyToken(regions) {
      for (const it of (regions[1] || [])) {
        for (const raw of splitToTokens(it.str)) {
          const tok = stripOuterPunct(raw);
          if (tok && isQtyToken(tok)) return tok;
        }
      }
      return "";
    }

    function findUnitToken(regions) {
      for (const it of (regions[2] || [])) {
        for (const raw of splitToTokens(it.str)) {
          const tok = stripOuterPunct(raw);
          if (tok && isLikelyUnitToken(tok)) return tok;
        }
      }
      return "";
    }

    function findMoneyByLabel(lineText, label) {
      const t = normalizeSpaces(lineText);
      const idx = t.indexOf(label);
      if (idx < 0) return null;
      const after = t.slice(idx + label.length);
      const parts = after.split(" ").filter(Boolean);
      for (const p of parts) {
        const m = parseMoneyToken(stripOuterPunct(p));
        if (m) return m;
      }
      return null;
    }

    function findPosCandidate(line, bPx, pageWidth, fullText) {
      const regions = lineRegions(line, bPx);
      const candidates = [];

      const dinOnLine = /\bDIN\b/i.test(fullText);

      function pushFromItems(items, regionIdx) {
        for (const it of items) {
          const toks = splitToTokens(it.str);
          for (const raw of toks) {
            const tok = stripOuterPunct(raw);
            if (!tok) continue;
            if (!isPosToken(tok)) continue;

            // Reject DIN-only integers like 18533 when DIN is on the same line
            if (dinOnLine && isIntegerPosCandidate(tok) && tok.length >= 4) continue;

            // Score
            let score = 0;
            if (isDottedNumericCode(tok) && endsWithFourDigits(tok)) score += 120;
            else if (isDottedNumericCode(tok)) score += 80;
            else if (isIntegerPosCandidate(tok)) score += 30; // keep low priority
            else score += 40;

            // Left bias
            score += Math.max(0, 25 - (it.x / Math.max(1, pageWidth)) * 25);

            // Region bias
            if (regionIdx === 0) score += 15;
            if (regionIdx === 1) score += 5;

            candidates.push({ tok, score, x: it.x });
          }
        }
      }

      pushFromItems(regions[0], 0);
      pushFromItems(regions[1], 1);

      if (candidates.length === 0) {
        const leftMost = line.items.slice(0, Math.min(6, line.items.length));
        pushFromItems(leftMost, 0);
      }

      if (!candidates.length) return null;
      candidates.sort((a,b)=> b.score - a.score || a.x - b.x);
      return candidates[0].tok;
    }

    // =========================
    // Noise filter (manual cuts are primary; repetition filter is secondary)
    // =========================
    async function buildNoiseSet(doc) {
      const occurrences = new Map();
      const topThresh = 0.90;
      const bottomThresh = 0.08;

      for (let p=1; p<=doc.numPages; p++) {
        const page = await doc.getPage(p);
        const viewport = page.getViewport({ scale: 1.0 });
        const textContent = await page.getTextContent();
        const { lines } = groupItemsIntoLines(textContent.items || [], viewport.height);
        for (const ln of lines) {
          const yNorm = ln.yNorm;
          if (!(yNorm >= topThresh || yNorm <= bottomThresh)) continue;
          const key = normalizeSpaces(ln.items.map(x => x.str).join(" ")).toLowerCase();
          if (!key) continue;
          if (key.length > 160) continue;
          occurrences.set(key, (occurrences.get(key) || 0) + 1);
        }
      }

      const noise = new Set();
      for (const [k, c] of occurrences.entries()) {
        if (c >= 2) noise.add(k);
      }
      return noise;
    }

    // =========================
    // Extraction (fail-safe fallback + header/footer cuts)
    // =========================
    function makeRow(seite, pos, qty, unit, ep, gp, desc) {
      return {
        "Seite": seite ?? "",
        "Pos": pos ?? "",
        "Menge": qty ?? "",
        "Menge Einheit": unit ?? "",
        "EP": ep ?? "",
        "GP": gp ?? "",
        "Beschreibung": desc ?? ""
      };
    }

    function flushOpenPosition(openPos, rowsOut) {
      if (!openPos) return null;
      const desc = openPos.descLines.filter(Boolean).join("\n").trim();
      rowsOut.push(makeRow(openPos.pageStart ?? "", openPos.pos ?? "", openPos.qty ?? "", openPos.unit ?? "", openPos.ep ?? "", openPos.gp ?? "", desc));
      return null;
    }

    function getPrimaryMode() {
      // Column boundaries: session > preset > auto
      // Cuts: session > preset > defaults
      const cuts = getActiveCuts();
      if ($("chkCalib").checked && sessionGuides && sessionGuides.boundariesNorm) {
        return { type: "session", boundariesNorm: sessionGuides.boundariesNorm, headerCut: cuts.headerCut, footerCut: cuts.footerCut };
      }
      if (preset && preset.boundariesNorm) {
        return { type: "preset", boundariesNorm: preset.boundariesNorm, headerCut: cuts.headerCut, footerCut: cuts.footerCut };
      }
      return { type: "auto", boundariesNorm: null, headerCut: cuts.headerCut, footerCut: cuts.footerCut };
    }

    function shouldIgnoreLineByCuts(yNorm, headerCut, footerCut) {
      if (yNorm >= headerCut) return true;
      if (yNorm <= footerCut) return true;
      return false;
    }

    function extractContext(mode, noiseSet) {
      const rows = [];
      let openPos = null;

      function processPage(p, viewport, textContent, pageModel) {
        const boundariesNorm = (mode.type === "session" || mode.type === "preset") ? mode.boundariesNorm : pageModel.boundariesNorm;
        const bPx = boundariesPx(boundariesNorm, viewport.width);

        const grouped = groupItemsIntoLines(textContent.items || [], viewport.height);
        const lines = grouped.lines;

        for (const ln of lines) {
          if (shouldIgnoreLineByCuts(ln.yNorm, mode.headerCut, mode.footerCut)) continue;

          const raw = ln.items.map(x => x.str).join(" ");
          const key = normalizeSpaces(raw).toLowerCase();
          if (noiseSet && noiseSet.has(key)) continue;

          const fullText = normalizeSpaces(raw);
          if (!fullText) continue;

          const regions = lineRegions(ln, bPx);

          // Field signals
          const qtyTok = findQtyToken(regions);
          const unitTok = findUnitToken(regions);
          const epInCol = findMoneyInItems(regions[3]);
          const gpInCol = findMoneyInItems(regions[4]);
          const epByLabel = findMoneyByLabel(fullText, "EP");
          const gpByLabel = findMoneyByLabel(fullText, "GP");
          const hasQtyOrPriceSignal = Boolean(qtyTok || unitTok || epInCol || gpInCol || epByLabel || gpByLabel);

          // Pos candidate (token-based, with DIN integer guard)
          const posTok = findPosCandidate(ln, bPx, viewport.width, fullText);

          // Title/Position decision
          if (posTok) {
            const titleLike = isTitleCode(posTok);

            // Integer pos candidates are only allowed when there is strong table signal and the token is truly "left"
            if (isIntegerPosCandidate(posTok) && posTok.length >= 4) {
              // Require qty/price signal and being in leftmost region visually
              if (!hasQtyOrPriceSignal) {
                // treat as normal text
              } else {
                // allow as position (rare)
              }
            }

            const posStrong = isDottedNumericCode(posTok) && endsWithFourDigits(posTok);
            const treatAsPosition = posStrong || (!titleLike) || (titleLike && hasQtyOrPriceSignal);

            if (treatAsPosition) {
              if (titleLike && !hasQtyOrPriceSignal) {
                // Title/Section row: only Pos + Beschreibung
                openPos = flushOpenPosition(openPos, rows);
                let descLine = removeTokenOnceByWhitespaceBoundary(fullText, posTok);
                rows.push(makeRow("", posTok, "", "", "", "", descLine));
                continue;
              }

              // New position
              openPos = flushOpenPosition(openPos, rows);
              openPos = { pageStart: p, pos: posTok, qty: "", unit: "", ep: "", gp: "", descLines: [] };

              if (qtyTok) openPos.qty = qtyTok.replace(/\s+/g,"").trim();
              if (unitTok) openPos.unit = unitTok.trim();
              const epNorm = epInCol ? epInCol.norm : (epByLabel || "");
              const gpNorm = gpInCol ? gpInCol.norm : (gpByLabel || "");
              if (epNorm) openPos.ep = epNorm;
              if (gpNorm) openPos.gp = gpNorm;

              // Description from same line
              let descLine = fullText;
              descLine = removeTokenOnceByWhitespaceBoundary(descLine, posTok);
              if (qtyTok) descLine = removeTokenOnceByWhitespaceBoundary(descLine, qtyTok);
              if (unitTok) descLine = removeTokenOnceByWhitespaceBoundary(descLine, unitTok);
              if (epInCol && epInCol.raw) descLine = removeTokenOnceByWhitespaceBoundary(descLine, epInCol.raw);
              if (gpInCol && gpInCol.raw) descLine = removeTokenOnceByWhitespaceBoundary(descLine, gpInCol.raw);

              if (isMeaningfulTextForDesc(descLine)) openPos.descLines.push(descLine);
              continue;
            }
          }

          // Continuation line
          if (openPos) {
            if (!openPos.qty && qtyTok) openPos.qty = qtyTok.replace(/\s+/g,"").trim();
            if (!openPos.unit && unitTok) openPos.unit = unitTok.trim();

            if (!openPos.ep) {
              const epNorm = epInCol ? epInCol.norm : (epByLabel || "");
              if (epNorm) openPos.ep = epNorm;
            }
            if (!openPos.gp) {
              const gpNorm = gpInCol ? gpInCol.norm : (gpByLabel || "");
              if (gpNorm) openPos.gp = gpNorm;
            }

            if (isMeaningfulTextForDesc(fullText)) {
              const usedForMoneyOnly = (isLeaderLine(fullText) && (epByLabel || gpByLabel || epInCol || gpInCol));
              if (!usedForMoneyOnly) openPos.descLines.push(fullText);
            }
          }
        }
      }

      return { rows, processPage, flush: () => { openPos = flushOpenPosition(openPos, rows); return rows; } };
    }

    async function runExtraction(mode, noiseSet, label) {
      log("Extraction run: " + label);
      const ctx = extractContext(mode, noiseSet);

      for (let p=1; p<=pdfDoc.numPages; p++) {
        const page = await pdfDoc.getPage(p);
        const viewport = page.getViewport({ scale: 1.0 });
        const textContent = await page.getTextContent();
        const pageModel = buildAutoColumnModel(textContent, viewport.width);
        ctx.processPage(p, viewport, textContent, pageModel);
      }
      return ctx.flush();
    }

    async function extractAllPagesWithFailSafe() {
      const noiseSet = await buildNoiseSet(pdfDoc);
      log("Noise filter built. Entries: " + noiseSet.size);

      const primary = getPrimaryMode();

      // Primary run
      let rows = await runExtraction(primary, noiseSet, primary.type === "auto" ? "auto clustering" : primary.type);

      // Fail-safe: if rows==0, retry with forced auto boundaries but KEEP user cuts (header/footer) because those are always helpful.
      if (rows.length === 0) {
        log("Zero rows detected. Retrying with auto clustering (ignoring column preset/guides, keeping header/footer cuts)...");
        const forced = { type: "auto", boundariesNorm: null, headerCut: primary.headerCut, footerCut: primary.footerCut };
        rows = await runExtraction(forced, noiseSet, "auto clustering (fail-safe)");
      }

      return rows;
    }

    // =========================
    // Export
    // =========================
    function exportXlsx() {
      if (!extractedRows || extractedRows.length === 0) return;
      const cols = ["Seite","Pos","Menge","Menge Einheit","EP","GP","Beschreibung"];
      const wsData = [cols];
      for (const r of extractedRows) wsData.push(cols.map(c => r[c] ?? ""));
      const ws = XLSX.utils.aoa_to_sheet(wsData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "LV");
      XLSX.writeFile(wb, "LVtoExcel_" + VERSION_TAG + ".xlsx");
      log("XLSX exported.");
    }

    // =========================
    // Wire up UI
    // =========================
    (function init() {
      $("kpiVersion").textContent = "VERSION_TAG=" + VERSION_TAG;
      log("Ready. VERSION_TAG=" + VERSION_TAG);

      $("fileInput").addEventListener("change", () => {
        const f = $("fileInput").files?.[0] || null;
        $("btnLoad").disabled = !f;
        $("btnExtract").disabled = true;
        $("btnExport").disabled = true;

        pdfDoc = null;
        currentPage = 1;
        extractedRows = [];
        preset = null;
        sessionGuides = null;
        autoModel = null;
        clearTable();

        if (f) {
          fileMetaKey = makeFileKey(f);
          preset = loadPresetForFile();
          updatePresetUI();
          setKpi();
          log("File selected: " + f.name);
        }
      });

      $("btnLoad").addEventListener("click", async () => {
        const f = $("fileInput").files?.[0];
        if (!f) return;
        try {
          const buf = await f.arrayBuffer();
          const loadingTask = pdfjsLib.getDocument({ data: buf });
          pdfDoc = await loadingTask.promise;
          currentPage = 1;

          log("PDF loaded. Pages: " + pdfDoc.numPages);

          $("btnPrev").disabled = false;
          $("btnNext").disabled = false;
          $("btnExtract").disabled = false;

          await renderCurrentPage();

          updatePresetUI();
          setKpi();
        } catch (e) {
          log("ERROR loading PDF: " + (e?.message || String(e)));
        }
      });

      $("btnPrev").addEventListener("click", async () => {
        if (!pdfDoc) return;
        currentPage = Math.max(1, currentPage - 1);
        await renderCurrentPage();
      });

      $("btnNext").addEventListener("click", async () => {
        if (!pdfDoc) return;
        currentPage = Math.min(pdfDoc.numPages, currentPage + 1);
        await renderCurrentPage();
      });

      $("chkCalib").addEventListener("change", () => {
        const enabled = $("chkCalib").checked;
        setGuidesEnabled(enabled);

        if (enabled) {
          // Initialize session guides from preset/auto/default (includes cuts)
          const b = (preset && preset.boundariesNorm) ? preset.boundariesNorm
                  : (autoModel && autoModel.boundariesNorm) ? autoModel.boundariesNorm
                  : DEFAULT_BOUNDARIES;
          const cuts = getActiveCuts();
          sessionGuides = { boundariesNorm: b.slice(), headerCut: cuts.headerCut, footerCut: cuts.footerCut };
        } else {
          sessionGuides = null;
        }

        applyGuides();
        updatePresetUI();
        setKpi();
      });

      $("btnSavePreset").addEventListener("click", () => {
        if (!$("chkCalib").checked) return;
        const b = getBoundariesFromGuidesV();
        const headerCut = sessionGuides?.headerCut ?? getActiveCuts().headerCut;
        const footerCut = sessionGuides?.footerCut ?? getActiveCuts().footerCut;
        const cuts = clampCuts(headerCut, footerCut);
        const p = { boundariesNorm: b, headerCut: cuts.headerCut, footerCut: cuts.footerCut };
        savePresetForFile(p);
        sessionGuides = { ...p };
        applyGuides();
        setKpi();
      });

      $("btnClearPreset").addEventListener("click", () => {
        clearPresetForFile();
        if (!$("chkCalib").checked) sessionGuides = null;
        applyGuides();
        setKpi();
      });

      $("btnExtract").addEventListener("click", async () => {
        if (!pdfDoc) return;
        $("btnExport").disabled = true;
        extractedRows = [];
        clearTable();

        // Refresh preset from storage
        preset = loadPresetForFile();

        setKpi();
        log("Extract started...");

        try {
          extractedRows = await extractAllPagesWithFailSafe();
          log("Extract done. Rows: " + extractedRows.length);
          renderTable(extractedRows);
          $("btnExport").disabled = extractedRows.length === 0;
        } catch (e) {
          log("ERROR extracting: " + (e?.message || String(e)));
        }
      });

      $("btnExport").addEventListener("click", exportXlsx);

      // Initial overlay
      applyGuides();
      setGuidesEnabled(false);
      updatePresetUI();
      setKpi();
    })();
  </script>
</body>
</html>
