<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LV → Excel (DREIPLUS Preset)</title>
  <style>
    body{font-family:system-ui,Arial,sans-serif;margin:0}
    .wrap{display:grid;grid-template-columns:440px 1fr;gap:12px;height:100vh}
    .panel{padding:12px;border-right:1px solid #ddd;overflow:auto}
    .viewer{padding:12px;overflow:auto}
    label{display:block;font-size:12px;margin-top:10px;color:#333}
    input,button,select{width:100%;box-sizing:border-box;padding:8px;margin-top:6px}
    .btnrow{display:flex;gap:8px;margin-top:10px}
    .btnrow button{flex:1}
    canvas{border:1px solid #ccc;max-width:100%;height:auto}
    pre{height:220px;overflow:auto;border:1px solid #ccc;background:#fff;padding:8px}
    .hint{font-size:12px;color:#666;margin-top:6px}
  </style>

  <!-- Local copies (NO CDN) -->
  <script src="./pdf.min.js"></script>
  <script src="./xlsx.full.min.js"></script>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <div class="hint">GitHub Pages (https) • DREIPLUS preset • PDF dosyası tarayıcıda kalır</div>

    <label>PDF seç</label>
    <input id="pdfFile" type="file" accept="application/pdf" />

    <label>Preset</label>
    <select id="preset">
      <option value="dreiplus" selected>DREIPLUS ZTV / LV-Texte</option>
    </select>

    <div class="btnrow">
      <button id="loadBtn">PDF laden</button>
      <button id="extractBtn">LV Extract</button>
    </div>

    <div class="btnrow">
      <button id="xlsxBtn">Export XLSX</button>
      <button id="csvBtn">Export CSV</button>
    </div>

    <div class="hint">
      Not: En iyi sonuç için LV sayfalarında “Nr. / Menge/Einheit / EP / GP” başlıklı tablo olmalı.
      Başlık sayfaları / kapaklar otomatik atlanır.
    </div>

    <label>Log</label>
    <pre id="log"></pre>
  </div>

  <div class="viewer">
    <canvas id="canvas"></canvas>
    <div id="out"></div>
  </div>
</div>

<script>
let pdfDoc = null;
let extractedRows = null;

const logEl = document.getElementById('log');
function log(msg){ logEl.textContent += msg + "\n"; logEl.scrollTop = logEl.scrollHeight; }

document.getElementById('loadBtn').addEventListener('click', loadPdf);
document.getElementById('extractBtn').addEventListener('click', extractLV);
document.getElementById('csvBtn').addEventListener('click', exportCSV);
document.getElementById('xlsxBtn').addEventListener('click', exportXLSX);

// ✅ Worker: aynı klasörde pdf.worker.min.js olmalı
if (window.pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
  pdfjsLib.GlobalWorkerOptions.workerSrc = "./pdf.worker.min.js";
}

async function loadPdf(){
  try{
    log("loadPdf() başladı…");
    if(!window.pdfjsLib) throw new Error("pdf.min.js yüklenmedi.");
    const f = document.getElementById("pdfFile").files[0];
    if(!f) { alert("Önce PDF seç."); return; }
    const buf = await f.arrayBuffer();
    log("PDF boyutu: " + (buf.byteLength/1024/1024).toFixed(2) + " MB");

    const loadingTask = pdfjsLib.getDocument({
      data: buf,
      disableFontFace: true,
      useSystemFonts: true,
      isEvalSupported: false,
      stopAtErrors: false,
    });

    loadingTask.onProgress = (p)=>{
      try{
        if(p && p.total){
          const pct = Math.round((p.loaded/p.total)*100);
          log("Yükleniyor: " + pct + "%");
        }
      }catch(e){}
    };

    pdfDoc = await loadingTask.promise;
    log("PDF geladen: " + pdfDoc.numPages + " Seiten");

    await renderPage(1);
    log("İlk sayfa çizildi.");
  }catch(e){
    log("HATA: " + (e && e.message ? e.message : e));
    alert("Hata: " + (e && e.message ? e.message : e));
  }
}

async function renderPage(pno){
  const page = await pdfDoc.getPage(pno);
  const vp = page.getViewport({ scale: 1.5 });
  const canvas = document.getElementById("canvas");
  canvas.width = Math.floor(vp.width);
  canvas.height = Math.floor(vp.height);
  await page.render({ canvasContext: canvas.getContext("2d"), viewport: vp }).promise;
}

// --- DREIPLUS extraction (position-based) ---

function normText(s){
  return (s||"").replace(/\s+/g," ").trim();
}

// Detect a “position / item number” in DREIPLUS LVs.
// Examples seen: 1.012.01.0010, 1.012.01, 1.012, 1.012.01.0010.0 (rare)
function looksLikePosNr(s){
  s = normText(s);
  if(!s) return false;
  // must contain at least one dot and digits
  if(!/^\d[\d\.]*\d$/.test(s)) return false;
  if(s.indexOf(".") === -1) return false;
  // avoid dates like 2024-... (hyphen) already excluded
  // common patterns:
  if(/^\d+(\.\d+)+$/.test(s)) return true;
  return false;
}

// Build lines from text items based on y coordinate.
function itemsToLines(items){
  // Each item has transform [a,b,c,d,e,f] => e=x, f=y (in PDF units)
  const pts = items
    .map(it => ({ x: it.transform[4], y: it.transform[5], s: normText(it.str) }))
    .filter(p => p.s);

  // Sort top->bottom (y desc), then left->right
  pts.sort((a,b)=> (b.y-a.y) || (a.x-b.x));

  const lines = [];
  const yTol = 2.2; // tolerance in PDF units; may tune
  for(const p of pts){
    let line = lines.find(l => Math.abs(l.y - p.y) <= yTol);
    if(!line){
      line = { y: p.y, parts: [] };
      lines.push(line);
    }
    line.parts.push({x:p.x, s:p.s});
  }

  // sort parts in each line
  for(const l of lines){
    l.parts.sort((a,b)=>a.x-b.x);
    l.text = l.parts.map(pp=>pp.s).join(" ").trim();
  }

  // sort lines top->bottom
  lines.sort((a,b)=>b.y-a.y);
  return lines;
}

// Column cut points (percentage of page width)
// DREIPLUS table: Nr | Menge/Einheit | EP | GP
function getCuts(pageWidth){
  // empiric: Nr ends ~20%, Menge/Einheit ends ~62%, EP ends ~82%
  return {
    nrMax: pageWidth * 0.22,
    qtyMax: pageWidth * 0.62,
    epMax: pageWidth * 0.82,
  };
}

function parseNumberDE(s){
  // "5,10" -> 5.10 ; "1.234,50" -> 1234.5
  s = normText(s);
  if(!s) return null;
  // keep digits, dot, comma, minus
  s = s.replace(/[^0-9,\.\-]/g,"");
  if(!s) return null;
  // remove thousand separators
  // if comma present, assume comma decimal
  if(s.indexOf(",") >= 0){
    s = s.replace(/\./g,"").replace(",", ".");
  }
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}

async function extractLV(){
  try{
    if(!pdfDoc){ alert("Önce PDF laden."); return; }
    log("LV Extract başladı…");

    const out = [];
    const preset = document.getElementById("preset").value;

    for(let p=1;p<=pdfDoc.numPages;p++){
      const page = await pdfDoc.getPage(p);
      const vp = page.getViewport({ scale: 1.0 });
      const width = vp.width;

      const tc = await page.getTextContent();
      const lines = itemsToLines(tc.items);

      // Skip pages without the header row (Nr / Menge/Einheit / EP / GP) -> not LV table pages
      const joined = lines.slice(0,40).map(l=>l.text).join(" | ");
      const isTablePage = /\bNr\.?\b/i.test(joined) && /Menge\/Einheit/i.test(joined) && /\bEP\b/i.test(joined);
      if(!isTablePage) continue;

      const cuts = getCuts(width);

      // We'll scan lines. When we see a new PosNr in "Nr column", start a new record.
      let current = null;

      for(const l of lines){
        // Build column texts from parts by x
        let nrTxt = "";
        let qtyTxt = "";
        let epTxt = "";
        let gpTxt = "";
        let restTxt = "";

        for(const part of l.parts){
          if(part.x <= cuts.nrMax) nrTxt += (nrTxt?" ":"") + part.s;
          else if(part.x <= cuts.qtyMax) qtyTxt += (qtyTxt?" ":"") + part.s;
          else if(part.x <= cuts.epMax) epTxt += (epTxt?" ":"") + part.s;
          else gpTxt += (gpTxt?" ":"") + part.s;
        }

        nrTxt = normText(nrTxt);
        qtyTxt = normText(qtyTxt);
        epTxt = normText(epTxt);
        gpTxt = normText(gpTxt);

        // ignore header lines
        const headerish = /\bNr\b/i.test(nrTxt) || /Menge\/Einheit/i.test(qtyTxt) || /^EP$/i.test(epTxt) || /^GP$/i.test(gpTxt);
        if(headerish) continue;

        // Detect new position
        if(looksLikePosNr(nrTxt)){
          // flush previous
          if(current){
            current.Beschreibung = (current.Beschreibung || '').trim();
            out.push(current);
          }
          current = {
            Seite: p,
            Pos: nrTxt,
            Menge: null,
            Einheit: null,
            EP: null,
            GP: null,
            Beschreibung: "",
          };

          // qtyTxt often contains either "m" or "2,50 m" etc.
          // We'll parse: last token as unit, preceding as qty if numeric.
          if(qtyTxt){
            const toks = qtyTxt.split(" ");
            if(toks.length === 1){
              // just unit
              current.Einheit = toks[0];
            }else{
              // try qty from first numeric-like token(s)
              // common: "m" only in some rows; or "1,00 m"
              const last = toks[toks.length-1];
              const maybeQty = toks.slice(0,-1).join(" ");
              const q = parseNumberDE(maybeQty);
              if(q !== null) current.Menge = q;
              current.Einheit = last;
            }
          }

          // Prices
          const ep = parseNumberDE(epTxt);
          const gp = parseNumberDE(gpTxt);
          if(ep !== null) current.EP = ep;
          if(gp !== null) current.GP = gp;

          // Remaining text to description: Some lines include "Title ..." right after pos
          // Many times description is in the middle column but not captured; we append full line minus numeric cols.
          const mid = l.parts
            .filter(pt => pt.x > cuts.nrMax && pt.x <= cuts.qtyMax)
            .map(pt => pt.s).join(" ").trim();
          // If mid contains words (not only qty/unit), treat as description seed.
          if(mid && !/^[0-9\s\.,\-]+\s*[a-zA-Z]{0,4}$/.test(mid)){
            current.Beschreibung += (current.Beschreibung ? " " : "") + mid;
          }
          continue;
        }

        // Continuation lines: append descriptive text (mostly in middle columns)
        if(current){
          // take everything between Nr and EP as "text block"
          const midParts = l.parts.filter(pt => pt.x > cuts.nrMax && pt.x <= cuts.epMax);
          const midText = normText(midParts.map(pt=>pt.s).join(" "));
          if(midText){
            // avoid appending pure numbers/units/prices
            const looksNumeric = /^[0-9\s\.,\-]+$/.test(midText);
            const looksUnitOnly = /^[a-zA-Z]{1,6}$/.test(midText);
            if(!looksNumeric && !looksUnitOnly && !/\bEP\b|\bGP\b/i.test(midText)){
              current.Beschreibung += (current.Beschreibung ? " " : "") + midText;
            }
          }

          // Sometimes Menge/Einheit/EP/GP appear on separate line without Nr (rare). Try fill missing:
          if(!current.Menge && qtyTxt){
            const toks = qtyTxt.split(" ");
            if(toks.length >= 2){
              const last = toks[toks.length-1];
              const maybeQty = toks.slice(0,-1).join(" ");
              const q = parseNumberDE(maybeQty);
              if(q !== null) current.Menge = q;
              if(!current.Einheit) current.Einheit = last;
            }
          }
          if(current.EP === null){
            const ep = parseNumberDE(epTxt);
            if(ep !== null) current.EP = ep;
          }
          if(current.GP === null){
            const gp = parseNumberDE(gpTxt);
            if(gp !== null) current.GP = gp;
          }
        }
      }

      // flush last on page end
      if(current){
        current.Beschreibung = current.Beschreibung.trim();
        out.push(current);
        current = null;
      }
    }

    extractedRows = out;

    log("Bitti. Bulunan poz sayısı: " + out.length);

    // Preview first 50
    let html = "<table border='1' style='border-collapse:collapse;font-size:12px'>";
    html += "<tr><th>Seite</th><th>Pos</th><th>Menge</th><th>Einheit</th><th>EP</th><th>GP</th><th>Beschreibung</th></tr>";
    out.slice(0,50).forEach(r=>{
      html += "<tr>" +
        "<td>"+r.Seite+"</td>"+
        "<td>"+escapeHtml(r.Pos)+"</td>"+
        "<td>"+(r.Menge??"")+"</td>"+
        "<td>"+escapeHtml(r.Einheit??"")+"</td>"+
        "<td>"+(r.EP??"")+"</td>"+
        "<td>"+(r.GP??"")+"</td>"+
        "<td>"+escapeHtml((r.Beschreibung||"").slice(0,200))+"</td>"+
      "</tr>";
    });
    html += "</table><div class='hint'>İlk 50 satır gösteriliyor. Export ile tümü iner.</div>";
    document.getElementById("out").innerHTML = html;

  }catch(e){
    log("HATA: " + (e && e.message ? e.message : e));
    alert("Hata: " + (e && e.message ? e.message : e));
  }
}

function escapeHtml(s){
  return String(s||"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
}

function exportCSV(){
  if(!extractedRows || !extractedRows.length){ alert("Önce LV Extract."); return; }
  const cols = ["Seite","Pos","Menge","Einheit","EP","GP","Beschreibung"];
  const esc = (v)=>(''+(v??'')).replace(/"/g,'""');
  const csv = cols.join(",") + "\n" + extractedRows.map(r =>
    cols.map(c => `"${esc(r[c])}"`).join(",")
  ).join("\n");
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([csv], {type:"text/csv;charset=utf-8"}));
  a.download = "dreiplus_lv.csv";
  a.click();
}

function exportXLSX(){
  if(!extractedRows || !extractedRows.length){ alert("Önce LV Extract."); return; }
  if(!window.XLSX){ alert("xlsx.full.min.js yüklenmedi."); return; }

  const header = ["Seite","Pos","Menge","Einheit","EP","GP","Beschreibung"];
  const data = [header, ...extractedRows.map(r => header.map(h => r[h] ?? ""))];
  const ws = XLSX.utils.aoa_to_sheet(data);
  ws["!cols"] = [
    { wch: 6 },  // Seite
    { wch: 18 }, // Pos
    { wch: 10 }, // Menge
    { wch: 8 },  // Einheit
    { wch: 10 }, // EP
    { wch: 10 }, // GP
    { wch: 80 }, // Beschreibung
  ];

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "DREIPLUS_LV");
  XLSX.writeFile(wb, "DREIPLUS_LV.xlsx");
}
</script>
</body>
</html>
