<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LVtoExcel Pro V9</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&family=Space+Grotesk:wght@500;600&display=swap" rel="stylesheet">
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    :root { 
        --accent: #0ea5a0; 
        --accent-2: #f59e0b;
        --ink: #1f2933;
        --muted: #667085;
        --border:#e3e7ef; 
        --bg:#f6f2ea; 
        --panel:#ffffff; 
        --danger:rgba(216, 42, 42, 0.35); 
        --success:#2f9e44; 
    }
    body { 
        font-family: "IBM Plex Sans", system-ui, sans-serif; 
        margin: 0; 
        color: var(--ink);
        background:
          radial-gradient(800px 300px at 10% -10%, #ffe9d6 0%, transparent 60%),
          radial-gradient(700px 300px at 110% -10%, #d8f6f4 0%, transparent 60%),
          linear-gradient(180deg, #f7f3ec 0%, #eef2f6 100%);
    }
    
    .navbar { 
        background: #1f232b; 
        color: white; 
        padding: 12px 20px; 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        position: sticky; 
        top: 0; 
        z-index: 1000; 
        box-shadow: 0 6px 24px rgba(0,0,0,0.18);
    }
    .brand { font-family: "Space Grotesk", sans-serif; font-weight: 600; letter-spacing: 0.3px; }
    .top-menu { position: sticky; top: 56px; z-index: 900; padding-top: 10px; backdrop-filter: blur(6px); }
    .container { max-width: 100%; margin: 10px auto 18px; padding: 0 16px; display: flex; flex-direction: column; gap: 16px; }
    .split { display: flex; gap: 15px; align-items: stretch; }
    .pane { flex: 1 1 0; min-width: 0; display: flex; flex-direction: column; }
    @media (max-width: 1100px) { 
        .split { flex-direction: column; } 
    }
    
    .card, .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 14px; box-shadow: 0 8px 24px rgba(15, 23, 42, 0.06); }
    .toolbar { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }

    .control-panel { display: flex; flex-direction: column; gap: 12px; }
    .panel-grid { display: grid; grid-template-columns: repeat(3, minmax(240px, 1fr)); gap: 12px; }
    .panel-header { display: flex; align-items: center; gap: 8px; font-weight: 600; color: var(--ink); font-family: "Space Grotesk", sans-serif; }
    .panel-body { display: grid; gap: 8px; margin-top: 10px; }
    .field-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .field { display: flex; gap: 8px; align-items: center; }
    .label { font-size: 12px; color: var(--muted); }
    .range-row { display: flex; gap: 6px; align-items: center; }
    .range-row input { width: 62px; padding: 4px 6px; }
    .range-row input:disabled { opacity: 0.5; cursor: not-allowed; }
    .layout { display: grid; grid-template-columns: 320px minmax(420px, 1fr) 320px; gap: 14px; align-items: start; }
    .side-stack { display: grid; gap: 12px; position: sticky; top: 120px; height: fit-content; max-height: calc(100vh - 140px); overflow: auto; }
    .column-list { display: grid; gap: 6px; }
    .col-item { display: flex; align-items: center; gap: 8px; padding: 8px 10px; border-radius: 10px; border: 1px solid #e2e8f0; cursor: pointer; background: #fff; }
    .col-item.active { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(14,165,160,0.15); }
    .swatch { width: 10px; height: 10px; border-radius: 999px; background: var(--accent); }
    .col-meta { font-size: 12px; color: var(--muted); }
    .sidebar h4 { margin: 4px 0 8px; font-size: 13px; font-weight: 600; color: var(--ink); }

    details.panel summary { cursor: pointer; list-style: none; }
    details.panel summary::-webkit-details-marker { display:none; }
    details.panel summary .panel-header::after { content:"▾"; margin-left:auto; color: var(--muted); font-size: 12px; }
    details.panel[open] summary .panel-header::after { content:"▴"; }

    .btn { padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: 13px; border: 1px solid rgba(27,31,36,0.15); transition: 0.2s; display: inline-flex; align-items: center; gap: 6px; background: #f6f7f9; }
    .btn-primary { background: var(--accent); color: white; border-color: transparent; }
    .btn-success { background: var(--success); color: white; border-color: transparent; }
    .btn-secondary { background: #eef1f5; }
    .btn-ghost { background: transparent; border: 1px dashed #cbd5e1; color: var(--muted); }
    .btn svg { width: 14px; height: 14px; }
    .pill { padding: 6px 10px; border-radius: 999px; background: #f1f5f9; border: 1px solid #e2e8f0; font-size: 12px; }
    .control-row { display: flex; align-items: center; justify-content: space-between; gap: 14px; flex-wrap: wrap; }
    .control-left, .control-right { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .divider { width: 1px; height: 28px; background: #e2e8f0; }
    .file-input { position: relative; overflow: hidden; }
    .file-input input { position: absolute; inset: 0; opacity: 0; cursor: pointer; }
    input[type="text"], input[type="number"], select {
        font-family: inherit;
        font-size: 13px;
        padding: 7px 10px;
        border-radius: 10px;
        border: 1px solid #e2e8f0;
        background: #fff;
        color: var(--ink);
    }
    input[type="number"] { width: 70px; }
    label { font-size: 13px; }

    /* PDF Viewer Area - UI FIX BURADA */
    #viewer-outer { 
        position: relative; background: #3a3f4b; border-radius: 12px; 
        overflow: auto; display: flex; justify-content: center; 
        max-height: 85vh; min-height: 360px; 
        padding: 52px 18px 18px 18px;
    }
    #canvas-wrapper { position: relative; display: inline-block; max-width: 100%; }
    canvas { display: block; box-shadow: 0 0 20px rgba(0,0,0,0.5); max-width: 100%; height: auto; }
    .guide-layer { position: absolute; top: 0; left: 0; cursor: crosshair; z-index: 100; }

    /* Sütun Ayarları Kutuları - UX FIX */
    #header-overlay { 
        position: absolute; top: -42px; left: 0; width: 100%; height: 42px; 
        pointer-events: none; z-index: 200; 
    }
    .col-label {
        position: absolute; height: 26px; background: rgba(255,255,255,0.95);
        border: 1px solid #d0d7de; border-left: 4px solid var(--accent);
        pointer-events: auto; padding: 4px 6px; font-size: 10px; box-sizing: border-box;
        display: flex; align-items: center; gap: 6px; border-radius: 6px; cursor: pointer;
    }
    .col-label.active { box-shadow: 0 0 0 2px rgba(14,165,160,0.15); }
    .col-label .dot { width: 8px; height: 8px; border-radius: 999px; }

    .zoom-ctrl { display: flex; align-items: center; gap: 6px; background: white; padding: 6px 10px; border-radius: 999px; border: 1px solid #e2e8f0; }
    .range-input { width: 62px; padding: 6px; border-radius: 8px; border: 1px solid #e2e8f0; }
    
    table { width: 100%; border-collapse: collapse; font-size: 11px; margin-top: 10px; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background: #f6f8fa; position: sticky; top: 0; }
    @media (max-width: 1300px) {
        .layout { grid-template-columns: 1fr; }
        .side-stack { position: static; max-height: none; }
    }
    @media (max-width: 1100px) { 
        .panel-grid { grid-template-columns: 1fr; }
        #viewer-outer { max-height: 60vh; padding: 52px 12px 12px 12px; }
    }
    @media (max-width: 700px) {
        .toolbar { gap: 6px; }
        .zoom-ctrl { padding: 4px 8px; }
        #viewer-outer { max-height: 55vh; min-height: 300px; padding: 48px 10px 10px 10px; }
        table { font-size: 10px; }
        th, td { padding: 6px; }
    }
  </style>
</head>
<body>

<nav class="navbar">
  <div class="brand">LVtoExcel Pro <span style="color:#6ee7b7;">V9</span></div>
  <div class="toolbar">
    <select id="langSelect" onchange="updateLocale()">
      <option value="tr">Türkçe</option>
      <option value="de">Deutsch</option>
      <option value="en">English</option>
    </select>
    <label class="btn btn-ghost file-input">
      <input type="file" id="fileInput" accept="application/pdf" />
      PDF Seç
    </label>
  </div>
</nav>

<div class="container">
  <div class="top-menu control-panel">
    <div class="panel">
      <div class="control-row">
        <div class="control-left">
          <div class="zoom-ctrl">
            <button onclick="changeZoom(-0.2)" class="btn btn-secondary" title="Yakınlaştır">-</button>
            <span id="zoomVal" class="pill">130%</span>
            <button onclick="changeZoom(0.2)" class="btn btn-secondary" title="Uzaklaştır">+</button>
          </div>
          <div class="divider"></div>
          <div class="field">
            <button id="btnPrev" class="btn" title="Önceki Sayfa">←</button>
            <span id="pageInfo" class="pill">0 / 0</span>
            <button id="btnNext" class="btn" title="Sonraki Sayfa">→</button>
          </div>
          <div class="divider"></div>
          <div class="field">
            <span class="label">Aralık</span>
            <input type="number" id="pageStart" class="range-input" value="1">
            <span>-</span>
            <input type="number" id="pageEnd" class="range-input" value="1">
          </div>
        </div>
        <div class="control-right">
          <button id="btnExtract" class="btn btn-primary" disabled>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3v12"/><path d="M7 10l5 5 5-5"/><path d="M5 21h14"/></svg>
            Veriyi Çek
          </button>
          <button id="btnExport" class="btn btn-success" disabled>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3v12"/><path d="M7 8l5-5 5 5"/><path d="M5 21h14"/></svg>
            Excel Aktar
          </button>
        </div>
      </div>
    </div>
  </div>

  <div class="layout">
    <aside class="side-stack">
      <details class="panel" open>
        <summary>
          <div class="panel-header">Hinweis Kuralları</div>
        </summary>
        <div class="panel-body">
          <div class="field-row">
            <label class="field"><input type="checkbox" id="hintUseKeywords" checked> Anahtar kelimeler</label>
            <input type="text" id="hintKeywords" placeholder="Hinweis, Vorbemerkung..." style="min-width:220px; flex:1" value="Hinweis, Vorbemerkung, Titel, Überschrift, Leistungsbeschreibung, Gilt für">
          </div>
          <div class="field-row">
            <label class="field"><input type="checkbox" id="hintUseBold"> Kalın yazı</label>
            <label class="field"><input type="checkbox" id="hintUseLarge"> Büyük font</label>
            <label class="field">Oran <input type="number" id="hintLargeRatio" class="range-input" value="1.2" step="0.05" min="1.05" max="2.0"></label>
          </div>
          <div class="field-row">
            <label class="field"><input type="checkbox" id="scopeStrictCols" checked> Menge/Einheit aramasını sadece seçili sütunlarda yap</label>
          </div>
        </div>
      </details>

      <details class="panel" open>
        <summary>
          <div class="panel-header">Pozisyon & Toplam</div>
        </summary>
        <div class="panel-body">
          <div class="field-row">
            <span class="label">Pos Regex Örnekleri</span>
            <input type="text" id="posSamples" placeholder="1.10.15, 1.10.15.10, 2.1., 3.4A" style="min-width:220px; flex:1">
            <button class="btn btn-secondary" onclick="generatePosRegex()">Oluştur</button>
          </div>
          <div class="field-row">
            <input type="text" id="posRegexOut" readonly style="min-width:220px; flex:1">
            <button class="btn btn-secondary" onclick="applyPosRegex()">Pozisyonlara Uygula</button>
          </div>
          <div class="field-row">
            <label class="field"><input type="checkbox" id="sumMakeNewRow" checked> Summe satırında yeni satır yap</label>
            <label class="field"><input type="checkbox" id="sumAppendDesc" checked> Açıklamaya ekle</label>
          </div>
          <div class="field-row">
            <input type="text" id="sumKeywords" value="Summe, Zwischensumme, Gesamtsumme, Teilsumme, Endsumme" style="min-width:220px; flex:1">
          </div>
        </div>
      </details>

      <details class="panel" open>
        <summary>
          <div class="panel-header">Mod & Otomatik Sütun</div>
        </summary>
        <div class="panel-body">
          <div class="field-row">
            <label class="field"><input type="checkbox" id="freeModeToggle"> Serbest Mod (kuralsız tablo)</label>
          </div>
          <div class="field-row">
            <label class="field"><input type="checkbox" id="autoColToggle" checked> Başlıkları algıla</label>
            <button class="btn btn-secondary" onclick="autoDetectColumns(true)">Açık Sayfayı Tara</button>
          </div>
          <div class="field-row">
            <label class="field"><input type="checkbox" id="colRangeToggle"> Sütun aralığını bağımsız kullan</label>
          </div>
        </div>
      </details>
    </aside>

    <div class="pane">
      <div id="viewer-outer">
        <div id="canvas-wrapper">
          <div id="header-overlay"></div>
          <canvas id="pdf-canvas"></canvas>
          <canvas id="guide-canvas" class="guide-layer"></canvas>
        </div>
      </div>
    </div>

    <aside class="side-stack">
      <div class="panel">
        <h4>Sütunlar</h4>
        <div id="columnList" class="column-list"></div>
        <div style="height:10px;"></div>
        <h4>Aktif Sütun</h4>
        <div class="panel-body">
          <div class="field-row">
            <span class="label">Başlık</span>
            <input type="text" id="colTitleInput" style="flex:1">
          </div>
          <div class="field-row">
            <span class="label">Tip</span>
            <select id="colTypeSelect">
              <option value="text">Metin</option>
              <option value="pos">Pozisyon</option>
              <option value="menge">Miktar</option>
              <option value="unit">Birim</option>
              <option value="currency">Para</option>
              <option value="desc">Beschreibung</option>
              <option value="free">Serbest</option>
            </select>
          </div>
          <div class="field-row" id="posRegexRow" style="display:none;">
            <span class="label">Regex</span>
            <input type="text" id="colRegexInput" style="flex:1">
          </div>
          <div class="field-row">
            <label class="field"><input type="checkbox" id="colMasterCheck"> Ana</label>
            <span class="label">Sıra</span>
            <input type="number" id="colMasterOrder" class="range-input" value="1" min="1" style="width:70px;">
          </div>
          <div class="field-row">
            <label class="field"><input type="checkbox" id="colRangeEnabled"> Aralık aktif</label>
          </div>
          <div class="field-row">
            <span class="label">Baş</span>
            <input type="number" id="colRangeStart" min="0" max="100" step="0.1">
            <span class="label">Bit</span>
            <input type="number" id="colRangeEnd" min="0" max="100" step="0.1">
          </div>
        </div>
      </div>
    </aside>
  </div>

  <div class="card">
    <div id="previewArea" style="overflow-x: auto; max-height: 55vh;"></div>
  </div>
</div>

<script>
/** AYNI ENGINE VE LOGIC SAKLANDI, SADECE UI IYILESTIRILDI **/
const VALID_EINHEITEN = new Set(['%', '°', '°C', 'A', 'AE', 'Bd', 'E', 'Hz', 'K', 'LE', 'ME', 'MW', 'N', 'Pa', 'V', 'VE', 'W', 'Wo', 'a', 'bar', 'cbm', 'cd', 'cm', 'cm2', 'cm3', 'cm²', 'cm³', 'd', 'dB', 'dm', 'Einheit', 'g', 'Grad', 'h', 'Jahr', 'kg', 'km', 'kN', 'kNm', 'kPa', 'kV', 'kW', 'kWh', 'l', 'lfm', 'lx', 'm', 'm2', 'm2Mt', 'm2Wo', 'm2d', 'm3', 'm3Mt', 'm3Wo', 'm3d', 'm²', 'm²Mt', 'm²Wo', 'm²d', 'm³', 'm³Mt', 'm³Wo', 'm³d', 'ma', 'mbar', 'md', 'mg', 'mh', 'mm', 'mMt', 'mWo', 'Monat', 'Mon', 'MPa', 'Mt', 'Nm', 'Paar', 'Pau', 'Prozent', 'Psch', 'Satz', 'Set', 'St', 'Std', 'Stk', 'Stk.', 'Sth', 'StMt', 'StWo', 'Stunde', 'Stück', 'Tag', 't', 'td', 'tMt', 'to', 'Tonne', 'tWo', 'Woche', 'pauschal', 'psch', 'qm', 'µg']);
const MENGE_PATTERNS = [/^0+\d*(\.\d+)?$/, /^\d+(\.\d+)?$/, /^\d+(\.\d*)*$/, /^\d+\s\d+$/, /^\d+\.\s\d+$/, /^\d{1,3}(\.\d{3})*,\d{2}$/, /^\d{1,3}(\.\d{3})*,\d{3}$/, /^\d+,\d{2}$/];

let pdfDoc = null, pageNum = 1, zoomFactor = 1.0, currentScale = 1.3, lang = 'tr';
let canvas = document.getElementById('pdf-canvas'), ctx = canvas.getContext('2d');
let gCanvas = document.getElementById('guide-canvas'), gCtx = gCanvas.getContext('2d');
let guides = { header: 0.08, footer: 0.92, cols: [0.1, 0.45, 0.6, 0.75, 0.88] };
let colSettings = [], columnRanges = [], isDragging = false, dragTarget = null, activeColumnIndex = 0;

const i18n = {
    tr: { master: "Ana", types: ["Metin", "Pozisyon", "Miktar", "Birim", "Para", "Beschreibung", "Serbest"], extract: "Veriyi Çek", export: "Excel Aktar" },
    de: { master: "Anker", types: ["Text", "Position", "Menge", "Einheit", "Euro", "Beschreibung", "Frei"], extract: "Extrahieren", export: "Export" },
    en: { master: "Master", types: ["Text", "Position", "Qty", "Unit", "Currency", "Description", "Free"], extract: "Extract", export: "Export" }
};

document.getElementById('fileInput').onchange = async (e) => {
    const ab = await e.target.files[0].arrayBuffer();
    pdfDoc = await pdfjsLib.getDocument(ab).promise;
    document.getElementById('pageEnd').value = pdfDoc.numPages;
    document.getElementById('btnExtract').disabled = false;
    renderPage(1);
    autoDetectColumns();
};

function changeZoom(delta) {
    zoomFactor = Math.min(3, Math.max(0.5, zoomFactor + delta));
    renderPage(pageNum);
}

async function renderPage(num) {
    if (!pdfDoc || num < 1 || num > pdfDoc.numPages) return;
    pageNum = num;
    document.getElementById('pageInfo').innerText = `${pageNum} / ${pdfDoc.numPages}`;
    const page = await pdfDoc.getPage(num);
    const vp1 = page.getViewport({ scale: 1.0 });
    const viewer = document.getElementById('viewer-outer');
    const availableWidth = Math.max(200, (viewer?.clientWidth || vp1.width) - 40);
    const fitScale = availableWidth / vp1.width;
    currentScale = Math.min(3, Math.max(0.2, fitScale * zoomFactor));
    const vp = page.getViewport({ scale: currentScale });
    canvas.width = gCanvas.width = vp.width;
    canvas.height = gCanvas.height = vp.height;
    await page.render({ canvasContext: ctx, viewport: vp }).promise;
    document.getElementById('zoomVal').innerText = Math.round(currentScale * 100) + "%";
    drawGuides();
}

function drawGuides() {
    const w = gCanvas.width, h = gCanvas.height;
    gCtx.clearRect(0, 0, w, h);
    gCtx.fillStyle = "rgba(207, 34, 46, 0.2)";
    gCtx.fillRect(0, 0, w, guides.header * h);
    gCtx.fillRect(0, guides.footer * h, w, h * (1 - guides.footer));
    syncColumnRangesFromBounds();
    if (useColumnRangesEnabled()) {
        columnRanges.forEach((r, i) => {
            if (r.enabled === false) return;
            const start = Math.max(0, Math.min(1, r.start));
            const end = Math.max(0, Math.min(1, r.end));
            const x = Math.min(start, end) * w;
            const width = Math.max(0.01, Math.abs(end - start)) * w;
            const color = (colSettings[i] && colSettings[i].color) ? colSettings[i].color : "#0ea5a0";
            gCtx.fillStyle = hexToRgba(color, 0.10);
            gCtx.fillRect(x, 0, width, h);
        });
        gCtx.strokeStyle = "rgba(14, 165, 160, 0.6)";
        gCtx.lineWidth = 1;
        gCtx.setLineDash([4, 4]);
        columnRanges.forEach((r) => {
            if (r.enabled === false) return;
            const start = Math.max(0, Math.min(1, r.start)) * w;
            const end = Math.max(0, Math.min(1, r.end)) * w;
            gCtx.beginPath(); gCtx.moveTo(start, 0); gCtx.lineTo(start, h); gCtx.stroke();
            gCtx.beginPath(); gCtx.moveTo(end, 0); gCtx.lineTo(end, h); gCtx.stroke();
        });
        gCtx.setLineDash([]);
    }
    gCtx.strokeStyle = "#cf222e"; gCtx.lineWidth = 2;
    [guides.header, guides.footer].forEach(y => { gCtx.beginPath(); gCtx.moveTo(0, y*h); gCtx.lineTo(w, y*h); gCtx.stroke(); });
    gCtx.strokeStyle = "#0969da"; gCtx.lineWidth = 1; gCtx.setLineDash([5, 3]);
    guides.cols.forEach(x => { gCtx.beginPath(); gCtx.moveTo(x*w, 0); gCtx.lineTo(x*w, h); gCtx.stroke(); });
    gCtx.setLineDash([]);
    updateHeaderOverlay();
}

function updateHeaderOverlay() {
    const overlay = document.getElementById('header-overlay');
    overlay.innerHTML = "";
    const bounds = [0, ...guides.cols, 1];
    syncColumnRangesFromBounds();
    const rangeEnabled = useColumnRangesEnabled();
    clampActiveColumn(bounds.length - 1);
    bounds.slice(0, -1).forEach((b, i) => {
        if(!colSettings[i]) colSettings[i] = { title: `Sütun ${i+1}`, type: 'text', regex: '^\\d+(?:\\.\\d+)*(?:\\.[A-Za-z])?\\.?$', isMaster: i === 0, masterOrder: i === 0 ? 1 : 0 };
        ensureColumnColor(i);
        const label = document.createElement('div');
        label.className = 'col-label' + (i === activeColumnIndex ? ' active' : '');
        label.style.left = (b * 100) + "%";
        label.style.width = ((bounds[i+1] - b) * 100) + "%";
        label.style.borderLeftColor = colSettings[i].color;
        label.innerHTML = `<span class="dot" style="background:${colSettings[i].color}"></span>${colSettings[i].title}`;
        label.onclick = () => setActiveColumn(i);
        overlay.appendChild(label);
    });
    renderColumnList();
    updateActiveColumnControls();
}

gCanvas.onmousedown = (e) => {
    const rect = gCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / gCanvas.width;
    const y = (e.clientY - rect.top) / gCanvas.height;
    if(Math.abs(y - guides.header) < 0.02) { isDragging = true; dragTarget = 'h'; return; }
    if(Math.abs(y - guides.footer) < 0.02) { isDragging = true; dragTarget = 'f'; return; }
    if (useColumnRangesEnabled()) {
        const hit = getRangeEdgeHit(e.clientX - rect.left, gCanvas.width);
        if (hit) { isDragging = true; dragTarget = { type: 'range', idx: hit.idx, edge: hit.edge }; return; }
    }
    let cIdx = guides.cols.findIndex(c => Math.abs(c - x) < 0.015);
    if(cIdx !== -1) { isDragging = true; dragTarget = cIdx; }
    else if(e.button === 0) { guides.cols.push(x); guides.cols.sort((a,b)=>a-b); colSettings = []; drawGuides(); }
};
gCanvas.oncontextmenu = (e) => {
    e.preventDefault();
    const rect = gCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / gCanvas.width;
    let cIdx = guides.cols.findIndex(c => Math.abs(c - x) < 0.02);
    if(cIdx !== -1) { guides.cols.splice(cIdx, 1); colSettings = []; drawGuides(); }
};
window.onmousemove = (e) => {
    if(!isDragging) return;
    const rect = gCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / gCanvas.width;
    const y = (e.clientY - rect.top) / gCanvas.height;
    if(dragTarget === 'h') guides.header = y;
    else if(dragTarget === 'f') guides.footer = y;
    else if(typeof dragTarget === 'number') guides.cols[dragTarget] = x;
    else if(dragTarget && dragTarget.type === 'range') {
        const idx = dragTarget.idx;
        const r = columnRanges[idx] || { start: 0, end: 1, manual: true, enabled: true };
        const val = Math.max(0, Math.min(1, x));
        if (dragTarget.edge === 'start') r.start = val;
        if (dragTarget.edge === 'end') r.end = val;
        r.manual = true; r.enabled = true;
        columnRanges[idx] = normalizeRange(r);
    }
    drawGuides();
};
window.onmouseup = () => { isDragging = false; dragTarget = null; };

function useColumnRangesEnabled() {
    return document.getElementById('colRangeToggle')?.checked;
}

function ensureColumnColor(idx) {
    const palette = ["#0ea5a0", "#f59e0b", "#8b5cf6", "#14b8a6", "#f97316", "#22c55e", "#3b82f6", "#ef4444"];
    if (!colSettings[idx]) return;
    if (!colSettings[idx].color) {
        colSettings[idx].color = palette[idx % palette.length];
    }
}

function renderColumnList() {
    const list = document.getElementById('columnList');
    if (!list) return;
    list.innerHTML = "";
    const count = guides.cols.length + 1;
    for (let i = 0; i < count; i++) {
        if (!colSettings[i]) colSettings[i] = { title: `Sütun ${i+1}`, type: 'text', regex: '^\\d+(?:\\.\\d+)*(?:\\.[A-Za-z])?\\.?$', isMaster: i === 0, masterOrder: i === 0 ? 1 : 0 };
        ensureColumnColor(i);
        const item = document.createElement('div');
        item.className = 'col-item' + (i === activeColumnIndex ? ' active' : '');
        item.onclick = () => setActiveColumn(i);
        item.innerHTML = `
          <span class="swatch" style="background:${colSettings[i].color}"></span>
          <div>
            <div>${colSettings[i].title}</div>
            <div class="col-meta">${getTypeLabel(colSettings[i].type)}</div>
          </div>
        `;
        list.appendChild(item);
    }
}

function getTypeLabel(type) {
    const map = { text: 0, pos: 1, menge: 2, unit: 3, currency: 4, desc: 5, free: 6 };
    const idx = map[type] ?? 0;
    return i18n[lang].types[idx] + " • " + type;
}

function setActiveColumn(idx) {
    activeColumnIndex = Math.max(0, Math.min(idx, guides.cols.length));
    updateHeaderOverlay();
}

function clampActiveColumn(count) {
    if (activeColumnIndex >= count) activeColumnIndex = Math.max(0, count - 1);
}

function updateActiveColumnControls() {
    if (!colSettings[activeColumnIndex]) return;
    const s = colSettings[activeColumnIndex];
    ensureColumnColor(activeColumnIndex);
    const titleEl = document.getElementById('colTitleInput');
    const typeEl = document.getElementById('colTypeSelect');
    const regexRow = document.getElementById('posRegexRow');
    const regexEl = document.getElementById('colRegexInput');
    const masterEl = document.getElementById('colMasterCheck');
    const orderEl = document.getElementById('colMasterOrder');
    const rangeEnabledEl = document.getElementById('colRangeEnabled');
    const rangeStartEl = document.getElementById('colRangeStart');
    const rangeEndEl = document.getElementById('colRangeEnd');
    if (titleEl) titleEl.value = s.title || "";
    if (typeEl) typeEl.value = s.type || "text";
    if (regexEl) regexEl.value = s.regex || "";
    if (regexRow) regexRow.style.display = (s.type === 'pos') ? 'flex' : 'none';
    if (masterEl) masterEl.checked = !!s.isMaster;
    if (orderEl) { orderEl.value = s.masterOrder || 1; orderEl.disabled = !s.isMaster; }
    syncColumnRangesFromBounds();
    const r = columnRanges[activeColumnIndex] || { start: 0, end: 1, enabled: true };
    if (rangeEnabledEl) rangeEnabledEl.checked = r.enabled !== false;
    if (rangeStartEl) rangeStartEl.value = Math.round(r.start * 1000) / 10;
    if (rangeEndEl) rangeEndEl.value = Math.round(r.end * 1000) / 10;
    const enableInputs = useColumnRangesEnabled() && r.enabled !== false;
    if (rangeStartEl) rangeStartEl.disabled = !enableInputs;
    if (rangeEndEl) rangeEndEl.disabled = !enableInputs;
}

function bindColumnControls() {
    const titleEl = document.getElementById('colTitleInput');
    const typeEl = document.getElementById('colTypeSelect');
    const regexEl = document.getElementById('colRegexInput');
    const masterEl = document.getElementById('colMasterCheck');
    const orderEl = document.getElementById('colMasterOrder');
    const rangeEnabledEl = document.getElementById('colRangeEnabled');
    const rangeStartEl = document.getElementById('colRangeStart');
    const rangeEndEl = document.getElementById('colRangeEnd');
    if (titleEl) titleEl.oninput = (e) => { colSettings[activeColumnIndex].title = e.target.value; updateHeaderOverlay(); };
    if (typeEl) typeEl.onchange = (e) => { colSettings[activeColumnIndex].type = e.target.value; updateHeaderOverlay(); };
    if (regexEl) regexEl.oninput = (e) => { colSettings[activeColumnIndex].regex = e.target.value; };
    if (masterEl) masterEl.onchange = (e) => { toggleMaster(activeColumnIndex, e.target.checked); };
    if (orderEl) orderEl.oninput = (e) => { setMasterOrder(activeColumnIndex, e.target.value); };
    if (rangeEnabledEl) rangeEnabledEl.onchange = (e) => { toggleColRangeEnabled(activeColumnIndex, e.target.checked); updateActiveColumnControls(); };
    if (rangeStartEl) rangeStartEl.oninput = (e) => { setColRange(activeColumnIndex, 'start', e.target.value); updateActiveColumnControls(); };
    if (rangeEndEl) rangeEndEl.oninput = (e) => { setColRange(activeColumnIndex, 'end', e.target.value); updateActiveColumnControls(); };
}

function normalizeRange(range) {
    if (!range) return { start: 0, end: 1, manual: false };
    let s = Math.max(0, Math.min(1, range.start));
    let e = Math.max(0, Math.min(1, range.end));
    if (e < s) [s, e] = [e, s];
    if (e - s < 0.01) e = Math.min(1, s + 0.01);
    return { ...range, start: s, end: e };
}

function syncColumnRangesFromBounds() {
    const bounds = [0, ...guides.cols, 1];
    const next = [];
    for (let i = 0; i < bounds.length - 1; i++) {
        const existing = columnRanges[i];
        if (existing && existing.manual) {
            next[i] = normalizeRange(existing);
        } else {
            next[i] = normalizeRange({ start: bounds[i], end: bounds[i+1], manual: false, enabled: true });
        }
        if (existing && typeof existing.enabled === 'boolean') next[i].enabled = existing.enabled;
    }
    columnRanges = next;
}

function setColRange(idx, which, value) {
    const v = Math.max(0, Math.min(100, parseFloat(value || 0)));
    syncColumnRangesFromBounds();
    const r = columnRanges[idx] || { start: 0, end: 1 };
    const val = v / 100;
    if (which === 'start') r.start = val;
    if (which === 'end') r.end = val;
    r.manual = true;
    r.enabled = true;
    columnRanges[idx] = normalizeRange(r);
    drawGuides();
}

function toggleColRangeEnabled(idx, checked) {
    syncColumnRangesFromBounds();
    const r = columnRanges[idx] || { start: 0, end: 1, manual: false };
    r.enabled = checked;
    columnRanges[idx] = normalizeRange(r);
    drawGuides();
}

function getRangeEdgeHit(xPx, width) {
    const threshold = 6;
    syncColumnRangesFromBounds();
    for (let i = 0; i < columnRanges.length; i++) {
        const r = columnRanges[i];
        if (r.enabled === false) continue;
        const s = Math.max(0, Math.min(1, r.start)) * width;
        const e = Math.max(0, Math.min(1, r.end)) * width;
        if (Math.abs(xPx - s) <= threshold) return { idx: i, edge: 'start' };
        if (Math.abs(xPx - e) <= threshold) return { idx: i, edge: 'end' };
    }
    return null;
}

function getColumnIndexForX(x, pageWidth) {
    const xNorm = x / Math.max(1, pageWidth);
    if (useColumnRangesEnabled()) {
        syncColumnRangesFromBounds();
        let best = -1;
        let bestWidth = Infinity;
        for (let i = 0; i < columnRanges.length; i++) {
            const r = columnRanges[i];
            if (r.enabled === false) continue;
            if (xNorm >= r.start && xNorm <= r.end) {
                const w = r.end - r.start;
                if (w < bestWidth) { bestWidth = w; best = i; }
            }
        }
        if (best !== -1) return best;
    }
    let cIdx = 0;
    for (let i = 0; i < guides.cols.length; i++) if (xNorm > guides.cols[i]) cIdx = i + 1;
    return cIdx;
}

function hexToRgba(hex, alpha) {
    const h = (hex || "").replace("#", "");
    const r = parseInt(h.substring(0, 2), 16) || 0;
    const g = parseInt(h.substring(2, 4), 16) || 0;
    const b = parseInt(h.substring(4, 6), 16) || 0;
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

document.getElementById('btnExtract').onclick = async () => {
    let extractedRows = [];
    const start = parseInt(document.getElementById('pageStart').value), end = parseInt(document.getElementById('pageEnd').value);
    const colCount = guides.cols.length + 1;
    for (let p = start; p <= end; p++) {
        const page = await pdfDoc.getPage(p), text = await page.getTextContent();
        const vp = page.getViewport({ scale: 1.0 }), h = vp.height, w = vp.width;
        let items = text.items.map(it => {
            const [vx, vy] = vp.convertToViewportPoint(it.transform[4], it.transform[5]);
            const fontSize = Math.abs(it.transform[3] || it.height || 0);
            const fontName = it.fontName || '';
            return { str: it.str, x: vx, y: vy, fontSize, fontName };
        }).filter(it => it.y > guides.header*h && it.y < guides.footer*h);
        const fontSizes = items.map(i => i.fontSize).filter(f => f > 0);
        const pageFontMedian = median(fontSizes) || 0;
        const lines = groupItemsIntoLines(items, w, colCount);
        const freeMode = isFreeMode();
        lines.forEach(line => {
            const fullText = line.cells.join(" ").replace(/\s+/g, " ").trim();
            const sumInfo = getSumInfo(line, fullText);
            if (!freeMode && isHintLine(line, fullText, pageFontMedian)) {
                const row = new Array(colCount).fill("");
                const descIdx = getDescColIndex();
                row[descIdx] = fullText;
                extractedRows.push(row);
                return;
            }
            if (!freeMode) {
                normalizePosCells(line);
                normalizeQtyUnitCells(line);
                applyDescPriority(line, fullText);
            }
            const masterCols = getMasterCols();
            let isNewRow = false;
            if (sumInfo.isSum && document.getElementById('sumMakeNewRow')?.checked) {
                isNewRow = true;
            } else {
                for (const idx of masterCols) {
                    const config = colSettings[idx];
                    const cell = (line.cells[idx] || "").trim();
                    if (!config) continue;
                    if (freeMode) {
                        if (cell.length > 0) { isNewRow = true; break; }
                    } else if (config.type === 'pos') {
                        const re = new RegExp(config.regex);
                        if (re.test(cell)) { isNewRow = true; break; }
                        const posTok = extractPosFromCell(cell);
                        if (posTok) { line.cells[idx] = posTok; isNewRow = true; break; }
                    } else if (config.type === 'currency') {
                        const toks = splitToTokens(cell);
                        for (const t of toks) {
                            if (parseMoneyToken(stripOuterPunct(t))) { isNewRow = true; break; }
                        }
                        if (isNewRow) break;
                    } else {
                        if (cell.length > 0) { isNewRow = true; break; }
                    }
                }
            }
            if (!freeMode && isNewRow && !sumInfo.isSum) applyQtyUnitRepair(line, fullText);
            if (sumInfo.isSum && document.getElementById('sumMakeNewRow')?.checked) {
                extractedRows.push([...line.cells]);
            } else if (sumInfo.hasKeyword && document.getElementById('sumAppendDesc')?.checked && extractedRows.length > 0) {
                const descIdx = getDescColIndex();
                const last = extractedRows[extractedRows.length - 1];
                last[descIdx] = (last[descIdx] ? last[descIdx] + "\n" : "") + fullText;
            } else if(isNewRow || extractedRows.length === 0) {
                extractedRows.push([...line.cells]);
            } else {
                let last = extractedRows[extractedRows.length - 1];
                line.cells.forEach((c, i) => { if(c) last[i] += "\n" + c; });
            }
        });
    }
    renderPreview(extractedRows);
};

function median(arr) {
    if (!arr.length) return 0;
    const s = arr.slice().sort((a,b)=>a-b);
    const m = Math.floor(s.length/2);
    return s.length % 2 ? s[m] : (s[m-1] + s[m]) / 2;
}

function normalizeSpaces(s) { return (s || "").replace(/\u00A0/g, " ").replace(/\s+/g, " ").trim(); }

function splitToTokens(str) {
    return normalizeSpaces(str).split(" ").filter(Boolean);
}

function stripOuterPunct(token) {
    let t = (token || "").trim();
    t = t.replace(/^[\(\[\{<]+/, "").replace(/[\)\]\}>]+$/, "");
    t = t.replace(/^[,:;]+/, "").replace(/[,:;]+$/, "");
    return t;
}

function escapeRegex(s) { return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }

function isDottedNumericCode(t) { return /^\d+(?:\.\d+)+$/.test(t.trim()); }
function endsWithFourDigits(code) { return /\.\d{4}$/.test(code.trim()); }
function isTitleCode(code) {
    if (!isDottedNumericCode(code)) return false;
    return !endsWithFourDigits(code);
}
function isPosToken(token) {
    const t = token.trim();
    if (!t) return false;
    if (isDottedNumericCode(t)) return true;
    if (/^\d{1,6}$/.test(t)) return true;
    if (/^[A-Z]\d{1,3}(?:[.-]\d{1,4})+$/i.test(t)) return true;
    return false;
}
function isIntegerPosCandidate(token) {
    const t = token.trim();
    return /^\d{1,6}$/.test(t);
}

function parseMoneyToken(token) {
    if (!token) return null;
    let t = token.replace(/\s+/g, "");
    t = t.replace(/[€$£]/g, "");
    if (!/\d/.test(t)) return null;
    if (t.includes(".") && t.includes(",")) {
        t = t.replace(/\./g, "");
        const m = t.match(/^(\d+),(\d{2,3})$/);
        if (!m) return null;
        return m[1] + "." + m[2];
    }
    if (t.includes(",")) {
        t = t.replace(/\./g, "");
        const m = t.match(/^(\d+),(\d{2,3})$/);
        if (!m) return null;
        return m[1] + "." + m[2];
    }
    const m = t.match(/^(\d+)\.(\d{2,3})$/);
    if (m) return m[1] + "." + m[2];
    return null;
}

function isQtyToken(token) {
    if (!token) return false;
    const t = token.replace(/\s+/g, "");
    if (/^\d+$/.test(t)) return true;
    if (/^\d+[.,]\d{1,3}$/.test(t)) return true;
    if (/^\d{1,3}(?:\.\d{3})+(?:,\d{1,3})?$/.test(t)) return true;
    return false;
}

function isLikelyUnitToken(token) {
    if (!token) return false;
    const t = stripOuterPunct(token);
    if (!t) return false;
    if (VALID_EINHEITEN.has(t)) return true;
    if (VALID_EINHEITEN.has(t.toLowerCase())) return true;
    return false;
}

function splitQtyUnitToken(token) {
    if (!token) return null;
    const t = stripOuterPunct(token);
    if (!t) return null;
    const m = t.match(/^(\d+(?:[.,]\d{1,3})?|\d{1,3}(?:\.\d{3})+(?:,\d{1,3})?)([A-Za-zµ²³]+)$/);
    if (!m) return null;
    const qty = m[1];
    const unit = m[2];
    if (!isQtyToken(qty)) return null;
    if (!isLikelyUnitToken(unit)) return null;
    return { qty, unit };
}

function groupItemsIntoLines(items, pageWidth, colCount) {
    const enriched = [];
    const heights = [];
    for (const it of items) {
        if (!it.str || !it.str.trim()) continue;
        const h = Math.abs(it.fontSize || 0);
        if (h > 1 && h < 80) heights.push(h);
        enriched.push({ ...it, h });
    }
    enriched.sort((a,b)=> a.y - b.y || a.x - b.x);
    const medH = median(heights) || 10;
    const yTol = Math.max(2.5, Math.min(12, medH * 0.45));
    const lines = [];
    for (const e of enriched) {
        let last = lines[lines.length-1];
        if (!last || Math.abs(last.y - e.y) > yTol) {
            lines.push({ y: e.y, cells: new Array(colCount).fill(""), items: [], fontSum: 0, fontCount: 0, hasBold: false });
            last = lines[lines.length-1];
        }
        let cIdx = getColumnIndexForX(e.x, pageWidth);
        last.cells[cIdx] += (last.cells[cIdx] ? " " : "") + e.str.trim();
        last.items.push(e);
        if (e.fontSize > 0) { last.fontSum += e.fontSize; last.fontCount += 1; }
        if (e.fontName && /bold|black|heavy|demi/i.test(e.fontName)) last.hasBold = true;
    }
    return lines;
}

function findPosCandidate(fullText, pageWidth) {
    const tokens = splitToTokens(fullText);
    const candidates = [];
    for (const raw of tokens) {
        const tok = stripOuterPunct(raw);
        if (!tok || !isPosToken(tok)) continue;
        let score = 0;
        if (isDottedNumericCode(tok) && endsWithFourDigits(tok)) score += 120;
        else if (isDottedNumericCode(tok)) score += 80;
        else if (isIntegerPosCandidate(tok)) score += 30;
        else score += 40;
        if (isTitleCode(tok)) score -= 15;
        candidates.push({ tok, score });
    }
    if (!candidates.length) return null;
    candidates.sort((a,b)=> b.score - a.score);
    return candidates[0].tok;
}

function extractPosFromCell(cellText) {
    if (!cellText) return null;
    const tokens = splitToTokens(cellText);
    for (const t of tokens) {
        const tok = stripOuterPunct(t);
        if (tok && isPosToken(tok)) return tok;
    }
    return null;
}

function isFreeMode() {
    const toggle = document.getElementById('freeModeToggle');
    if (toggle && toggle.checked) return true;
    return colSettings.some(s => s && s.type === 'free');
}

async function autoDetectColumns(currentPageOnly=false) {
    const toggle = document.getElementById('autoColToggle');
    if (toggle && !toggle.checked) return;
    if (!pdfDoc) return;
    const pages = currentPageOnly ? [pageNum] : Array.from({length: Math.min(3, pdfDoc.numPages)}, (_, i) => i + 1);
    for (const p of pages) {
        const page = await pdfDoc.getPage(p);
        const vp = page.getViewport({ scale: 1.0 });
        const text = await page.getTextContent();
        const items = text.items.map(it => {
            const [vx, vy] = vp.convertToViewportPoint(it.transform[4], it.transform[5]);
            const fontSize = Math.abs(it.transform[3] || it.height || 0);
            const width = it.width || 0;
            return { str: it.str, x: vx, y: vy, fontSize, w: width };
        });
        const detected = detectHeaderColumns(items, vp.width);
        if (detected) {
            guides.cols = detected.bounds;
            colSettings = detected.colSettings;
            columnRanges = [];
            ensureMasterSelection();
            normalizeMasterOrders();
            drawGuides();
            return;
        }
    }
}

function detectHeaderColumns(items, pageWidth) {
    const HEADER_KEYWORDS = {
        pos: ['Ordnungszahl', 'OZ', 'OZ.', 'Pos', 'Position', 'Positionsnr', 'Positionsnummer'],
        desc: ['Leistungsbeschreibung', 'Beschreibung', 'Text', 'Kurztext', 'Langtext'],
        menge: ['Menge'],
        unit: ['ME', 'Einheit', 'Mengeneinheit'],
        ep: ['Einheitspreis', 'EP'],
        gp: ['Gesamtbetrag', 'Gesamtpreis', 'GP', 'Gesamt', 'Summe']
    };
    const lines = buildLinesForHeader(items);
    for (const ln of lines) {
        const found = { pos: null, desc: null, menge: null, unit: null, ep: null, gp: null };
        for (const it of ln.items) {
            const s = (it.str || "").trim();
            if (!s) continue;
            const sLower = s.toLowerCase();
            for (const key of Object.keys(HEADER_KEYWORDS)) {
                if (found[key] !== null) continue;
                for (const variant of HEADER_KEYWORDS[key]) {
                    const v = variant.trim();
                    if (!v) continue;
                    let ok = false;
                    let idx = -1;
                    if (v.length <= 2) {
                        const re = new RegExp("(^|\\b)" + escapeRegex(v) + "(\\b|$)", "i");
                        const m = re.exec(s);
                        ok = Boolean(m);
                        idx = m ? m.index : -1;
                    } else {
                        idx = sLower.indexOf(v.toLowerCase());
                        ok = idx !== -1;
                    }
                    if (ok) { 
                        const len = Math.max(1, s.length);
                        const baseX = (it.w && it.w > 0 && idx >= 0) ? (it.x + (it.w * (idx / len))) : it.x;
                        found[key] = baseX;
                        break; 
                    }
                }
            }
        }
        if (found.desc !== null && found.menge !== null && found.ep !== null && found.gp !== null) {
            if (found.unit === null) {
                found.unit = (found.menge + found.ep) / 2;
            }
            const clampNorm = (x) => Math.max(0.02, Math.min(0.98, (x - 1) / pageWidth));
            const bounds = [
                clampNorm(found.desc),
                clampNorm(found.menge),
                clampNorm(found.unit),
                clampNorm(found.ep),
                clampNorm(found.gp)
            ];
            const colSettingsLocal = [
                { title: 'Ordnungszahl', type: 'pos', regex: '^\\d+(?:\\.\\d+)*(?:\\.[A-Za-z])?\\.?$', isMaster: true, masterOrder: 1 },
                { title: 'Leistungsbeschreibung', type: 'desc', regex: '^\\d+(?:\\.\\d+)*(?:\\.[A-Za-z])?\\.?$', isMaster: false, masterOrder: 0 },
                { title: 'Menge', type: 'menge', regex: '^\\d+(?:\\.\\d+)*(?:\\.[A-Za-z])?\\.?$', isMaster: false, masterOrder: 0 },
                { title: 'ME', type: 'unit', regex: '^\\d+(?:\\.\\d+)*(?:\\.[A-Za-z])?\\.?$', isMaster: false, masterOrder: 0 },
                { title: 'Einheitspreis', type: 'currency', regex: '^\\d+(?:\\.\\d+)*(?:\\.[A-Za-z])?\\.?$', isMaster: false, masterOrder: 0 },
                { title: 'Gesamtbetrag', type: 'currency', regex: '^\\d+(?:\\.\\d+)*(?:\\.[A-Za-z])?\\.?$', isMaster: false, masterOrder: 0 }
            ];
            return { bounds, colSettings: colSettingsLocal };
        }
    }
    return null;
}

function buildLinesForHeader(items) {
    const heights = [];
    const enriched = [];
    for (const it of items) {
        if (!it.str || !it.str.trim()) continue;
        const h = Math.abs(it.fontSize || 0);
        if (h > 1 && h < 80) heights.push(h);
        enriched.push({ ...it, h });
    }
    const medH = median(heights) || 10;
    const yTol = Math.max(2.5, Math.min(12, medH * 0.45));
    enriched.sort((a,b)=> a.y - b.y || a.x - b.x);
    const lines = [];
    for (const e of enriched) {
        let last = lines[lines.length-1];
        if (!last || Math.abs(last.y - e.y) > yTol) {
            lines.push({ y: e.y, items: [e] });
        } else {
            last.items.push(e);
        }
    }
    for (const ln of lines) ln.items.sort((a,b)=>a.x - b.x);
    return lines;
}

function getSumInfo(line, fullText) {
    const raw = document.getElementById('sumKeywords')?.value || "";
    const keys = raw.split(",").map(s => s.trim().toLowerCase()).filter(Boolean);
    const t = (fullText || "").toLowerCase();
    let hasKeyword = false;
    for (const k of keys) {
        if (k && t.includes(k)) { hasKeyword = true; break; }
    }
    const currencyIdxs = [];
    for (let i = 0; i < colSettings.length; i++) {
        if (colSettings[i] && colSettings[i].type === 'currency') currencyIdxs.push(i);
    }
    let hasCurrency = false;
    for (const idx of currencyIdxs) {
        const cell = (line.cells[idx] || "").trim();
        if (!cell) continue;
        const toks = splitToTokens(cell);
        for (const tok of toks) {
            if (parseMoneyToken(stripOuterPunct(tok))) { hasCurrency = true; break; }
        }
        if (hasCurrency) break;
    }
    return { hasKeyword, hasCurrency, isSum: hasKeyword && hasCurrency };
}

function generatePosRegex() {
    const raw = document.getElementById('posSamples')?.value || "";
    const samples = raw.split(/[,\n;]+/).map(s => s.trim()).filter(Boolean);
    if (!samples.length) return;
    let hasDot = false;
    let allowTrailingDot = false;
    let allowLetter = false;
    for (const s of samples) {
        if (s.includes(".")) hasDot = true;
        if (/\.$/.test(s)) allowTrailingDot = true;
        if (/[A-Za-z]$/.test(s)) allowLetter = true;
    }
    let regex = "^\\d+";
    if (hasDot) regex += "(?:\\.\\d+)*";
    if (allowLetter) regex += "(?:\\.[A-Za-z])?";
    if (allowTrailingDot) regex += "\\.?";
    regex += "$";
    const out = document.getElementById('posRegexOut');
    if (out) out.value = regex;
}

function applyPosRegex() {
    const out = document.getElementById('posRegexOut');
    const regex = out?.value || "";
    if (!regex) return;
    for (let i = 0; i < colSettings.length; i++) {
        if (colSettings[i] && colSettings[i].type === 'pos') {
            colSettings[i].regex = regex;
        }
    }
    updateHeaderOverlay();
}

function applyQtyUnitRepair(line, fullText) {
    const mengeIdx = colSettings.findIndex(s => s && s.type === 'menge');
    const unitIdx = colSettings.findIndex(s => s && s.type === 'unit');
    const strict = document.getElementById('scopeStrictCols')?.checked;
    const mengeTokens = (mengeIdx !== -1 ? splitToTokens(line.cells[mengeIdx] || "") : []);
    const unitTokens = (unitIdx !== -1 ? splitToTokens(line.cells[unitIdx] || "") : []);
    const tokens = strict ? [] : splitToTokens(fullText);
    if (mengeIdx !== -1 && unitIdx !== -1 && (!line.cells[mengeIdx] || !line.cells[unitIdx])) {
        const search = strict ? mengeTokens.concat(unitTokens) : tokens;
        for (const raw of search) {
            const pair = splitQtyUnitToken(raw);
            if (!pair) continue;
            if (!line.cells[mengeIdx]) line.cells[mengeIdx] = pair.qty;
            if (!line.cells[unitIdx]) line.cells[unitIdx] = pair.unit;
            break;
        }
    }
    if (mengeIdx !== -1 && unitIdx !== -1 && (!line.cells[mengeIdx] || !line.cells[unitIdx])) {
        // handle "1,45 10.765 cm" (qty + qty + unit) patterns
        const search = strict ? mengeTokens.concat(unitTokens) : tokens;
        for (let i = 0; i < search.length - 1; i++) {
            const a = stripOuterPunct(search[i]);
            const b = stripOuterPunct(search[i+1]);
            const c = stripOuterPunct(search[i+2] || "");
            if (!line.cells[mengeIdx] && isQtyToken(a)) {
                // accept patterns like "1,45 10.765 cm" where second number is part of measure
                if (isQtyToken(b) && isLikelyUnitToken(c)) {
                    line.cells[mengeIdx] = a + " " + b;
                    line.cells[unitIdx] = c;
                    break;
                }
            }
        }
    }
    if (mengeIdx !== -1 && !line.cells[mengeIdx]) {
        const search = strict ? mengeTokens : tokens;
        for (const raw of search) {
            const tok = stripOuterPunct(raw);
            if (isQtyToken(tok)) { line.cells[mengeIdx] = tok; break; }
        }
    }
    if (unitIdx !== -1 && !line.cells[unitIdx]) {
        const search = strict ? unitTokens : tokens;
        for (const raw of search) {
            const tok = stripOuterPunct(raw);
            if (isLikelyUnitToken(tok)) { line.cells[unitIdx] = tok; break; }
        }
    }
}

function normalizeQtyUnitCells(line) {
    const mengeIdx = colSettings.findIndex(s => s && s.type === 'menge');
    const unitIdx = colSettings.findIndex(s => s && s.type === 'unit');
    if (mengeIdx === -1 || unitIdx === -1) return;
    const mengeCell = (line.cells[mengeIdx] || "").trim();
    const unitCell = (line.cells[unitIdx] || "").trim();
    // If Menge cell already has qty+unit (e.g. "10m2" or "10 m2"), split it
    if (mengeCell && !unitCell) {
        const tokens = splitToTokens(mengeCell);
        if (tokens.length === 1) {
            const pair = splitQtyUnitToken(tokens[0]);
            if (pair) {
                line.cells[mengeIdx] = pair.qty;
                line.cells[unitIdx] = pair.unit;
                return;
            }
        }
        if (tokens.length >= 2) {
            const qtyTok = stripOuterPunct(tokens[0]);
            const unitTok = stripOuterPunct(tokens[1]);
            if (isQtyToken(qtyTok) && isLikelyUnitToken(unitTok)) {
                line.cells[mengeIdx] = qtyTok;
                line.cells[unitIdx] = unitTok;
                return;
            }
        }
    }
    // If Einheit cell has "10m2" and Menge is empty, split there too
    if (!mengeCell && unitCell) {
        const tokens = splitToTokens(unitCell);
        if (tokens.length === 1) {
            const pair = splitQtyUnitToken(tokens[0]);
            if (pair) {
                line.cells[mengeIdx] = pair.qty;
                line.cells[unitIdx] = pair.unit;
                return;
            }
        }
    }
}

function getHintConfig() {
    const useKeywords = document.getElementById('hintUseKeywords').checked;
    const useBold = document.getElementById('hintUseBold').checked;
    const useLarge = document.getElementById('hintUseLarge').checked;
    const ratioRaw = parseFloat(document.getElementById('hintLargeRatio').value);
    const largeRatio = isFinite(ratioRaw) ? ratioRaw : 1.2;
    const raw = document.getElementById('hintKeywords').value || "";
    const keywords = raw.split(",").map(s => s.trim()).filter(Boolean).map(s => s.toLowerCase());
    return { useKeywords, useBold, useLarge, largeRatio, keywords };
}

function normalizePosCells(line) {
    const descIdx = getDescColIndex();
    for (let i = 0; i < colSettings.length; i++) {
        const cfg = colSettings[i];
        if (!cfg || cfg.type !== 'pos') continue;
        const raw = (line.cells[i] || "").trim();
        if (!raw) continue;
        const re = new RegExp(cfg.regex);
        if (re.test(raw)) continue;
        // Try to extract a pos token from the cell text
        const tokens = splitToTokens(raw);
        let posTok = null;
        for (const t of tokens) {
            const tok = stripOuterPunct(t);
            if (tok && isPosToken(tok)) { posTok = tok; break; }
        }
        if (posTok) {
            const rest = normalizeSpaces(raw.replace(posTok, ""));
            line.cells[i] = posTok;
            if (rest) {
                line.cells[descIdx] = (line.cells[descIdx] ? line.cells[descIdx] + " " : "") + rest;
            }
        } else {
            // Not a pos at all, move to description and clear pos cell
            line.cells[i] = "";
            if (raw) {
                line.cells[descIdx] = (line.cells[descIdx] ? line.cells[descIdx] + " " : "") + raw;
            }
        }
    }
}

function lineHasNumericSignal(line, fullText) {
    const mengeIdx = colSettings.findIndex(s => s && s.type === 'menge');
    const unitIdx = colSettings.findIndex(s => s && s.type === 'unit');
    const currencyIdx = colSettings.findIndex(s => s && s.type === 'currency');
    const strict = document.getElementById('scopeStrictCols')?.checked;
    const tokens = strict ? [] : splitToTokens(fullText);
    const sumInfo = getSumInfo(line, fullText);
    if (sumInfo.isSum) return true;
    if (mengeIdx !== -1 && (line.cells[mengeIdx] || "").trim()) return true;
    if (unitIdx !== -1 && (line.cells[unitIdx] || "").trim()) return true;
    if (currencyIdx !== -1 && (line.cells[currencyIdx] || "").trim()) return true;
    if (!strict) {
        for (const raw of tokens) {
            const tok = stripOuterPunct(raw);
            if (isQtyToken(tok)) return true;
            if (isLikelyUnitToken(tok)) return true;
            if (parseMoneyToken(tok)) return true;
        }
    }
    return false;
}

function applyDescPriority(line, fullText) {
    const descIdx = getDescColIndex();
    if (descIdx === null || descIdx === undefined) return;
    // If a pos cell is present, don't collapse the row into description
    for (let i = 0; i < colSettings.length; i++) {
        const cfg = colSettings[i];
        if (cfg && cfg.type === 'pos' && (line.cells[i] || "").trim()) return;
    }
    if (lineHasNumericSignal(line, fullText)) return;
    let combined = "";
    for (let i = 0; i < line.cells.length; i++) {
        if (i === descIdx) continue;
        if (colSettings[i] && colSettings[i].type === 'pos') continue;
        const c = (line.cells[i] || "").trim();
        if (!c) continue;
        combined = combined ? combined + " " + c : c;
        line.cells[i] = "";
    }
    if (combined) {
        const cur = (line.cells[descIdx] || "").trim();
        line.cells[descIdx] = cur ? (cur + " " + combined) : combined;
    }
}

function getDescColIndex() {
    const idxDesc = colSettings.findIndex(s => s && s.type === 'desc');
    if (idxDesc !== -1) return idxDesc;
    const idxText = colSettings.findIndex(s => s && s.type === 'text');
    if (idxText !== -1) return idxText;
    return getPrimaryMaster() ?? 0;
}

function isHintLine(line, fullText, pageFontMedian) {
    if (!fullText) return false;
    const cfg = getHintConfig();
    let hit = false;
    if (cfg.useKeywords && cfg.keywords.length) {
        const t = fullText.toLowerCase();
        for (const k of cfg.keywords) {
            if (k && t.includes(k)) { hit = true; break; }
        }
    }
    if (!hit && cfg.useBold && line.hasBold) hit = true;
    if (!hit && cfg.useLarge && pageFontMedian > 0) {
        const avg = line.fontCount > 0 ? (line.fontSum / line.fontCount) : 0;
        if (avg >= pageFontMedian * cfg.largeRatio) hit = true;
    }
    return hit;
}

function getMasterCols() {
    const cols = [];
    for (let i = 0; i < colSettings.length; i++) {
        if (colSettings[i] && colSettings[i].isMaster) {
            const order = Number(colSettings[i].masterOrder) || 0;
            cols.push({ idx: i, order });
        }
    }
    if (!cols.length) return [0];
    cols.sort((a,b) => (a.order || 999) - (b.order || 999) || a.idx - b.idx);
    return cols.map(c => c.idx);
}

function getPrimaryMaster() {
    const cols = getMasterCols();
    return cols.length ? cols[0] : null;
}

function ensureMasterSelection() {
    const any = colSettings.some(s => s && s.isMaster);
    if (!any && colSettings[0]) colSettings[0].isMaster = true;
}

function normalizeMasterOrders() {
    const masters = [];
    for (let i = 0; i < colSettings.length; i++) {
        const s = colSettings[i];
        if (s && s.isMaster) masters.push({ idx: i, order: Number(s.masterOrder) || 0 });
    }
    masters.sort((a,b)=> (a.order || 999) - (b.order || 999) || a.idx - b.idx);
    let n = 1;
    for (const m of masters) {
        colSettings[m.idx].masterOrder = n++;
    }
}

function toggleMaster(idx, checked) {
    if (!colSettings[idx]) return;
    colSettings[idx].isMaster = checked;
    if (checked && !colSettings[idx].masterOrder) {
        const maxOrder = Math.max(0, ...colSettings.map(s => (s && s.isMaster) ? (Number(s.masterOrder) || 0) : 0));
        colSettings[idx].masterOrder = maxOrder + 1;
    }
    if (!checked) colSettings[idx].masterOrder = 0;
    ensureMasterSelection();
    normalizeMasterOrders();
    updateHeaderOverlay();
}

function setMasterOrder(idx, value) {
    if (!colSettings[idx]) return;
    let v = parseInt(value, 10);
    if (!isFinite(v) || v < 1) v = 1;
    colSettings[idx].masterOrder = v;
    normalizeMasterOrders();
    updateHeaderOverlay();
}

function renderPreview(data) {
    const div = document.getElementById('previewArea');
    let h = `<table><tr>${colSettings.map(s => `<th>${s.title}</th>`).join('')}</tr>`;
    data.forEach(r => h += `<tr>${r.map(c => `<td>${c.replace(/\n/g,'<br>')}</td>`).join('')}</tr>`);
    div.innerHTML = h + `</table>`;
    window.lastExtracted = data; document.getElementById('btnExport').disabled = false;
}

document.getElementById('btnExport').onclick = () => {
    const sheetData = [colSettings.map(s => s.title)];
    window.lastExtracted.forEach(row => {
        sheetData.push(row.map((cell, i) => {
            const type = colSettings[i].type;
            if(type === 'text' || type === 'pos' || type === 'desc' || type === 'unit' || type === 'free') return cell;
            let n = cell.replace(/[^0-9,.-]/g, '').replace(',','.');
            return parseFloat(n) || cell;
        }));
    });
    const ws = XLSX.utils.aoa_to_sheet(sheetData);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Export");
    XLSX.writeFile(wb, `LV_Export_V8.xlsx`);
};

function updateLocale() {
    lang = document.getElementById('langSelect').value;
    document.getElementById('btnExtract').innerText = i18n[lang].extract;
    document.getElementById('btnExport').innerText = i18n[lang].export;
    updateHeaderOverlay();
}
document.getElementById('btnPrev').onclick = () => renderPage(pageNum-1);
document.getElementById('btnNext').onclick = () => renderPage(pageNum+1);
window.addEventListener('resize', () => {
    if (pdfDoc) renderPage(pageNum);
});
document.getElementById('colRangeToggle').onchange = () => {
    syncColumnRangesFromBounds();
    drawGuides();
};
bindColumnControls();
updateLocale();
</script>
</body>
</html>
